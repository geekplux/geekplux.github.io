<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekPlux</title>
  <subtitle>知行合一</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://geekplux.com/"/>
  <updated>2018-03-16T16:12:12.826Z</updated>
  <id>http://geekplux.com/</id>
  
  <author>
    <name>GeekPlux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在不规则多边形内均匀撒点的算法</title>
    <link href="http://geekplux.com/2018/03/16/how-to-picking-uniform-points-in-irregular-polygon.html"/>
    <id>http://geekplux.com/2018/03/16/how-to-picking-uniform-points-in-irregular-polygon.html</id>
    <published>2018-03-16T15:55:25.000Z</published>
    <updated>2018-03-16T16:12:12.826Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>给定一个不规则的多边形（可能是凹多边形，可能是凸多边形），在其中要显示拓扑网络数据，要求节点不重合、不超出边界。</p>
</blockquote>
<h2 id="该问题出现的场景："><a href="#该问题出现的场景：" class="headerlink" title="该问题出现的场景："></a>该问题出现的场景：</h2><ul>
<li>在地图上撒点</li>
<li>在未知画布上生成初始的拓扑布局</li>
</ul>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><h3 id="方法一-随机撒点"><a href="#方法一-随机撒点" class="headerlink" title="方法一 随机撒点"></a>方法一 随机撒点</h3><p>取凸多边形的外接矩形，在矩形中<strong>随机撒点</strong>，如果落在凸多边形外，再次随机撒点，直至落在凸多边形内。<br>这个方法比较<strong>暴力</strong>，可以通过计算期望来控制撒点次数，撒点次数应该符合泊松分布。</p>
<h3 id="方法二-把不规则多边形切割成若干三角形"><a href="#方法二-把不规则多边形切割成若干三角形" class="headerlink" title="方法二 把不规则多边形切割成若干三角形"></a>方法二 把不规则多边形切割成若干三角形</h3><p>可以看作方法一的改进。切成多个三角形之后，问题转化为了如何在多个三角形内撒点。</p>
<p>参考：<a href="https://beta.observablehq.com/@scarysize/finding-random-points-in-a-polygon" target="_blank" rel="external">https://beta.observablehq.com/@scarysize/finding-random-points-in-a-polygon</a><br>切割库：<a href="https://github.com/mapbox/earcut" target="_blank" rel="external">https://github.com/mapbox/earcut</a></p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/picking-points/d21d62d4-7411-4ec9-8b33-99357ee16c12.png" alt="earcut 切割效果"></p>
<p>三角形是凸多边形，如何在三角形内均匀撒点可参考：<a href="http://mathworld.wolfram.com/TrianglePointPicking.html" target="_blank" rel="external">http://mathworld.wolfram.com/TrianglePointPicking.html</a></p>
<p>算法步骤：</p>
<ol>
<li>随机选取任意一三角形</li>
<li>在三角形内撒点</li>
<li>重复12，直到点撒完</li>
</ol>
<p><strong>这里有个问题*</strong>：每个三角形被选取的概率相同，但三角形面积不同。这就可能出现小面积三角形中的点和大面积三角形中的点个数差不多，从而造成总体上看起来点集中在小面积三角形中的情况。<br>所以要<strong>保证三角形被选取的概率跟它的面积成正比</strong>。</p>
<h3 id="方法三-用力导向迭代"><a href="#方法三-用力导向迭代" class="headerlink" title="方法三 用力导向迭代"></a>方法三 用力导向迭代</h3><p>可以看作是 方法二 的改进。给随机撒好的点设置相同的电荷力，使其不停迭代到稳定状态，即形成下图状态，达到尽量“均匀”。</p>
<p>参考：<a href="https://bl.ocks.org/mbostock/1b64ec067fcfc51e7471d944f51f1611" target="_blank" rel="external">https://bl.ocks.org/mbostock/1b64ec067fcfc51e7471d944f51f1611</a></p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/picking-points/792ca119-0d62-4f24-94bc-db219491392e.png" alt="力导向迭代效果"></p>
<h3 id="方法四-用四叉树生成点"><a href="#方法四-用四叉树生成点" class="headerlink" title="方法四 用四叉树生成点"></a>方法四 用四叉树生成点</h3><p>和前三种方法无关。用四叉树将二维空间切割成相等大小的正方形，然后用正方形图心撒点。</p>
<p>参考：<a href="https://www.phase2technology.com/blog/using-d3-quadtrees-power-interactive-map-bonnier-corporation" target="_blank" rel="external">https://www.phase2technology.com/blog/using-d3-quadtrees-power-interactive-map-bonnier-corporation</a></p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/picking-points/22c8a130-0a60-4004-966c-1264903bee6c.png" alt="四叉树效果"><br><img src="http://7b1evr.com1.z0.glb.clouddn.com/picking-points/fe26c3c9-3e1e-4702-9773-22b86e193986.png" alt="四叉树效果"></p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个不规则的多边形（可能是凹多边形，可能是凸多边形），在其中要显示拓扑网络数据，要求节点不重合、不超出边界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;该问题出现的场景：&quot;&gt;&lt;a href=&quot;#该问题出现的场景：&quot; class=&quot;he
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
      <category term="Algorithm" scheme="http://geekplux.com/categories/Visualization/Algorithm/"/>
    
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Algorithm" scheme="http://geekplux.com/tags/Algorithm/"/>
    
      <category term="算法" scheme="http://geekplux.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Web 前端中的增强现实（AR）开发技术</title>
    <link href="http://geekplux.com/2018/01/18/augmented-reality-development-tech-in-web-frontend.html"/>
    <id>http://geekplux.com/2018/01/18/augmented-reality-development-tech-in-web-frontend.html</id>
    <published>2018-01-17T16:24:21.000Z</published>
    <updated>2018-01-18T02:08:47.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文作者 <a href="http://geekplux.com/">GeekPlux</a>，首发于<a href="https://qianduan.group/posts/5a5f89cb0cf6b624d2239c65" target="_blank" rel="external">前端外刊评论-Web 前端中的增强现实（AR）开发技术</a>，博客地址：<a href="http://geekplux.com/2018/01/16/augmented-reality-development-tech-in-web-frontend.html">http://geekplux.com/2018/01/18/augmented-reality-development-tech-in-web-frontend.html</a>。注明作者和地址即可转载。</p>
</blockquote>
<p>增强现实（以下简称 AR）浪潮正滚滚而来，Web 浏览器作为人们最唾手可得的人机交互终端，正在大力发展 AR 技术。很多 Web 前端工程师也在寻求职业转型，于是我把我近半年的相关调研结果在此汇结成文。本文力求把目前前端方向的 AR 技术都罗列一遍，细节不赘述（<em>保证文章篇幅不过长</em>），只做概括和科普（<em>因此文章中的链接很多</em>），零零散散写了一个多月（拖延症），欢迎已经在从事该领域或研究的道友前来纠正补充。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/screenshot-nexus9.png" alt="Web AR 初音未来"></p>
<p>AR 可以简单的理解为一种实时将虚拟图像叠加在现实场景中的技术，且能交互[1]。我个人觉得 AR 比 VR 要有前景，主要因为：</p>
<blockquote>
<p>AR 的优势在于把目之所及的现实场景变成了背景，并将现实世界和数字世界无缝连接。</p>
</blockquote>
<p>当然这个“无缝”目前还谈不上，不过一直在进步。在谈 Web 前端如何做 AR 前，有必要先了解一下 AR 实现的 2 种主要方式和其关键技术：</p>
<h2 id="AR-实现的方式和关键技术"><a href="#AR-实现的方式和关键技术" class="headerlink" title="AR 实现的方式和关键技术"></a>AR 实现的方式和关键技术</h2><p>AR 的主要实现方式有 2 种[2][3]：光学透视式 (Optical see-through) 和视频透视式 (Video see-through)。目前，市面上的头戴式设备通常采用 2 种方式中的 1 种或 2 种都采用，而手持设备（手机、平板等）通常采用视频透视式。光学透视式是将电脑生成的数字图像显示在眼前的一层半透明镜片上，这样就可以使现实场景和虚拟信息同时出现在视网膜上。而视频透视式技术是将现实场景首先通过相机录入电脑，经过和虚拟对象整合、压缩，再统一呈现在用户眼前。两者各有优劣[4]：光学透视式中的现实场景因为没有经过电脑处理，因此显示得更自然、直接；虽然它实现简单，但是也存在定位精度不高、匹配不准确、显示有延迟等问题。而视频透视式因为经过整合，所以匹配准确，最终显示效果同步程度高，还能对生成的显示结果根据用户需求进行进一步处理；但是它实现难度较高，且丢失了一部分真实感。<strong>目前（2017 年底） Web 前端要想实现 AR，都是靠的视频透视式技术</strong>。</p>
<p>另外，计算机视觉技术在 AR 中起着至关重要的作用。因为<strong>实现 AR 最核心的是识别与追踪</strong>。首先，相机要先识别基准标志、关键点、光学图片等；然后再根据特征检测、边缘检测或其他图像处理方法来实时追踪；最后将虚拟图像叠加到真实场景中。根据 2008 年的统计结果显示，近十年著名的 AR 会议 ISMAR 中有关追踪技术的论文占到了 20%以上[3].</p>
<h2 id="Web-AR"><a href="#Web-AR" class="headerlink" title="Web AR"></a>Web AR</h2><p>根据上一节的阐述，我们可以得出结论：要实现 AR 需要<strong>识别、追踪和渲染</strong>三步，在浏览器中也不外如是。另外，还可以结合传感器来提供更多的交互或让 AR 渲染得更准确、通过网络连接云端来加速计算或交换更多数据等。如下图所示，这是我自己整理出的一个 Web AR 流程图。Web AR 或者说移动 AR 在某些方面如便携性、传感器丰富、自带网络等还是有很大优势的，在此我就不多说了。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Web AR 流程图"></p>
<h3 id="WebVR-规范"><a href="#WebVR-规范" class="headerlink" title="WebVR 规范"></a>WebVR 规范</h3><p>首先，Web AR 目前还是一项前沿技术，没有标准也没有成熟的库供使用，不过已经有大公司和一部分开发者正在积极推进。2017 年 10 月 2 日 W3C 的 <a href="https://www.w3.org/community/webvr/" target="_blank" rel="external">WebVR 组</a> 发布了 <a href="https://w3c.github.io/webvr/spec/1.1/" target="_blank" rel="external">WebVR 规范 1.1 版的初稿</a>，2.0 版还在热火朝天地修订当中。</p>
<blockquote>
<p>WebVR 是一个开放标准，使您可以在浏览器中体验 VR。我们的目标是让每个人都可以更轻松地体验 VR，无论您拥有什么设备。 -  <a href="https://webvr.info/" target="_blank" rel="external">webvr.info</a></p>
</blockquote>
<p>为什么本文的题目是 Web AR，这里却提到 WebVR 呢？因为 <strong>WebVR 规范中的部分 API 对 Web AR 也同样适用</strong>。比如 <a href="https://w3c.github.io/webvr/spec/latest/#pose" target="_blank" rel="external">VRDevicePose</a> 可以获取摄像头位置。这是目前唯一接近 Web AR 的标准，有了标准我们就可以只针对规范的接口做开发，从而适应绝大多数的设备。扩展阅读：<a href="https://medium.com/arjs/webvr-for-augmented-reality-f1e69a505902" target="_blank" rel="external">WebVR 于增强现实</a>，<a href="https://github.com/google-ar/three.ar.js/blob/master/webvr_ar_extension.md" target="_blank" rel="external">针对智能手机 AR 的 WebVR API 扩展</a>。</p>
<h3 id="WebARonARKit-WebARonARCore"><a href="#WebARonARKit-WebARonARCore" class="headerlink" title="WebARonARKit, WebARonARCore"></a>WebARonARKit, WebARonARCore</h3><p>ARKit 和 ARCore 分别是苹果和谷歌两大巨头出品的移动 AR SDK，提供的功能也类似：运动追踪、环境感知和光线感应，我相信很多对 AR 感兴趣的开发者对这两个 SDK 都不陌生。但这两个都是移动 AR 的 SDK，于是谷歌的 AR 团队提供了 <a href="https://github.com/google-ar/WebARonARKit" target="_blank" rel="external">WebARonARKit</a> 和 <a href="https://github.com/google-ar/WebARonARCore" target="_blank" rel="external">WebARonARCore</a> 两个库，以便开发者<strong>能用 Web 技术来基于 ARKit 和 ARCore 开发，从而实现 WebAR</strong>。目前这两个库都还在试验阶段，想吃螃蟹的人赶紧去试试。其实现原理都是结合特定系统（iOS 和 Android）扩展了 WebVR API。Google AR 团队封装了一个 <a href="https://github.com/google-ar/three.ar.js" target="_blank" rel="external">three.ar.js</a> 的库，提供了一些实用的 AR API，包括 ARView, ARReticle, ARPerspectiveCamera, ARDebug 和 ARUtils 等。</p>
<h3 id="AR-js"><a href="#AR-js" class="headerlink" title="AR.js"></a>AR.js</h3><p>2017 年 SIGGRAPH（图形学顶级会议）上 <a href="https://github.com/jeromeetienne/AR.js" target="_blank" rel="external">AR.js</a> 可谓大放异彩，有人做了 Web AR <a href="https://twitter.com/Tojiro/status/892440983371042816" target="_blank" rel="external">相关的 session</a> 就是用了 AR.js 来讲解。AR.js 是 <a href="https://twitter.com/jerome_etienne" target="_blank" rel="external">Jerome Etienne</a> 开发的一款 Web AR 库，可以<a href="https://medium.com/arjs/augmented-reality-in-10-lines-of-html-4e193ea9fdbf" target="_blank" rel="external">用十行 HTML 就实现 AR</a>，并有 60 FPS 的帧率。但其实 AR.js 做的事很简单，它主要封装了以下几个库：</p>
<ul>
<li>WebRTC。下文会详细讲解，主要是获取视频流。</li>
<li><a href="https://github.com/artoolkit/jsartoolkit5" target="_blank" rel="external">JSARToolKit</a>。<a href="https://www.artoolkit.org/" target="_blank" rel="external">ARToolKit</a> 可以说是第一个开源的 AR 框架，在 1999 年发布，一直更新至今。虽然历史悠久但目前仍被广泛应用（<a href="https://www.artoolkit.org" target="_blank" rel="external">官方网站</a>的风格一点也没有历史感）。它主要提供了识别和追踪 marker 的功能，本文附录中还有补充。</li>
<li>Three.js, Babylon.js, A-Frame。这几个都是基于 WebGL 的渲染库，用于渲染要在 AR 环境中显示的东西，下文会扩充。</li>
</ul>
<p>由此观之，AR.js 像是一个把所有轮子都拼起来的瑞士军刀，简单易用。作者在 GitHub 和 Twitter 上都很活跃，有什么问题可以直接问他。</p>
<h3 id="WebRTC-获取视频流"><a href="#WebRTC-获取视频流" class="headerlink" title="WebRTC 获取视频流"></a>WebRTC 获取视频流</h3><p>前三节我们提到了一个正在成形的标准和两个框架，是目前 Web AR 的最新进展了。指望标准发布肯定黄花菜都凉了，但我们可以自己动手丰衣足食。</p>
<p>刚才我们说到 AR 首先要识别，那就要用到 WebRTC 技术。WebRTC（Web 实时通信，Web Real-Time Communication），顾名思义是一个支持网页浏览器进行实时语音对话或视频对话的技术。它其中有个很重要的 API：<strong>getUserMedia()</strong> 可以实时获取摄像头的视频流，这是视频透视式的 AR 实现的前提（目前 iOS 11 刚刚支持这个 API，Android 是很早就能用）。有了视频流我们就可以分析其中的特征点，运用计算机视觉的算法识别和追踪视频流中的事物。这里有 2 个要点也要提一下：一是 getUserMedia 默认获取的是前置摄像头，如果想获取后置摄像头的视频流，需要用 navigator.mediaDevices.enumerateDevices() 将设备的音频、视频设备遍历得到，具体参照 <a href="https://github.com/geekplux/AR-AI-VIS-demo/blob/master/src/index.js#L9-L32" target="_blank" rel="external">demo</a>；二是要用 https 打开网页才能访问摄像头。</p>
<h3 id="Tracking-js-JSFeat-ConvNetJS-deeplearn-js-keras-js-识别与追踪"><a href="#Tracking-js-JSFeat-ConvNetJS-deeplearn-js-keras-js-识别与追踪" class="headerlink" title="Tracking.js, JSFeat, ConvNetJS, deeplearn.js, keras.js 识别与追踪"></a>Tracking.js, JSFeat, ConvNetJS, deeplearn.js, keras.js 识别与追踪</h3><p>获取到视频流之后的工作就是识别和追踪了。视频流你可以看作是一帧一帧的图像，所以处理视频流的过程可以理解为图像处理的过程。但这里其实还涉及到一个如何传输视频流的问题，一般有两种方式：</p>
<h4 id="1-在前端直接处理视频流"><a href="#1-在前端直接处理视频流" class="headerlink" title="1. 在前端直接处理视频流"></a>1. 在前端直接处理视频流</h4><p>在前端直接进行图像处理，可以用 <a href="https://trackingjs.com/" target="_blank" rel="external">Tracking.js</a> 和 <a href="https://inspirit.github.io/jsfeat/" target="_blank" rel="external">JSFeat</a>。这两个库类似，都是在前端做计算机视觉的，包括提取特征点、人脸识别等。把 WebRTC 拿到的视频流直接传给它们并调用 API 就能得到自己想要的效果。对于一些成熟的算法，如人脸识别，可以直接拿到识别结果，如果自己要识别的物体比较复杂你也可以自己进行特征点的计算，但这可能在前端会算力不足，关于性能的问题下文再论述。</p>
<p>提到计算机视觉，不得不提深度学习，毕竟现在很多图像处理算法被深度学习吊打。<a href="https://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">ConvNetJS</a>，是斯坦福大学开源的一个前端深度学习框架，可以让你在前端完成深度神经网络的训练。<a href="https://deeplearnjs.org/" target="_blank" rel="external">deeplearn.js</a> 则是 Google Brain 团队搞的，功能和 ConvNetJS 类似。现在 ConvNetJS 好像不怎么维护了，deeplearn.js 还在频繁更新中，感兴趣的同学可以试用一下。另外一个紧锣密鼓开发的深度学习库 <a href="https://github.com/transcranial/keras-js" target="_blank" rel="external">keras.js</a> 则是让你可以在浏览器中运行已经训练好的 Keras 模型（<a href="https://github.com/keras-team/keras" target="_blank" rel="external">Kears</a> 是著名的深度学习开发框架），并支持 WebGL 2。</p>
<p>这些框架都在主页上提供了丰富的 Demo，非常有趣，把玩一下说不定激发你的灵感。</p>
<h4 id="2-前端传输视频流给后端，后端处理完毕返回结果到前端"><a href="#2-前端传输视频流给后端，后端处理完毕返回结果到前端" class="headerlink" title="2. 前端传输视频流给后端，后端处理完毕返回结果到前端"></a>2. 前端传输视频流给后端，后端处理完毕返回结果到前端</h4><p>另一种处理视频流的方法就是传到后端去处理，后端处理方式的选择就数不胜数了，现在实现 AR 大多数用的都是 <a href="https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping" target="_blank" rel="external">SLAM</a> 算法，后端处理完返回前端结果即可。那么如何传输成了我们前端同学的难题，一般有这两种方法：</p>
<ul>
<li>传图片信息给后端。Canvas 提供了两个 API，一个是 toDataURL，它可以生成图片的 base64 字符串；另一个是 toBlob，这个方法是异步的，可以将图片转换成 Blob 文件对象，因为其是二进制的，所以更方便传给后端。具体使用来看，后者比前者的效率更高一点。</li>
<li>传像素信息给后端。WebGL 的 readPixels 方法，可以获取 framebuffer 中的像素值。</li>
</ul>
<p>除此之外应该还有其他方法，总之目标是将前端的图像信息传给后端，传输方式可以用 AJAX，也可以用 WebSocket，具体根据场景来定。</p>
<p>这一节主要讲了识别和追踪，其实除了单纯的对图像、视频流处理，我们还能通过移动端设备的各种传感器数据获取到更多的距离、深度、光照等信息，从而使识别追踪更准确。</p>
<h3 id="A-Frame-Three-js-Babylon-js-Pixi-js-WebGL-渲染与交互"><a href="#A-Frame-Three-js-Babylon-js-Pixi-js-WebGL-渲染与交互" class="headerlink" title="A-Frame, Three.js, Babylon.js, Pixi.js, WebGL 渲染与交互"></a>A-Frame, Three.js, Babylon.js, Pixi.js, WebGL 渲染与交互</h3><p>讲完识别和追踪，终于该聊聊渲染了。<a href="https://aframe.io/" target="_blank" rel="external">A-Frame</a> 是 Mozilla 团队在 2015 年开源的一款做 WebVR 的框架，但日前 A-Frame 团队发布的 <a href="https://github.com/mozilla/aframe-xr" target="_blank" rel="external">aframe-xr</a> 其中包括了一些 Web AR 组件。一开始我们也说过 VR 和 AR 中有部分实现是重合的，所以用 A-Frame 的各种组件可以让你用很少的代码<a href="http://elevr.com/using-a-frame-for-webvr-and-ar/" target="_blank" rel="external">构建出 AR 所需要的 3D 立体世界</a>。提到 3D，不得不提 <a href="https://www.khronos.org/webgl/" target="_blank" rel="external">WebGL</a>。WebGL 是 OpenGL ES 在浏览器端的实现，你可以理解其为 OpenGL 的子集。用 WebGL 你可以操作前端的每一个像素点，懂一点图形学的同学一定知道它的强大，而且它能调用 GPU，所以前端涉及到 GPU 的地方也缺不了它。WebGL 虽然强大，但写起来异常复杂，学习成本也很高，而前端最著名的 3D 库 <a href="https://threejs.org/" target="_blank" rel="external">Three.js</a> 将繁琐的 WebGL API 进行了封装和优化，让你可以用可读性更好的代码在前端书写 WebGL。<a href="http://www.pixijs.com/" target="_blank" rel="external">Pixi.js</a> 和 Three.js 做了类似的事情，但它只支持 2D 渲染，不过它还是很好用的，如果你只是想用 WebGL 来做复杂的渲染但没涉及到 3D 场景，不妨试试它。<a href="https://www.babylonjs.com/" target="_blank" rel="external">Babylon.js</a> 就更牛了，它是一款游戏引擎，也是封装了 WebGL 在前端做高性能的渲染，但它和 Three.js 的关注点不一样，如果你对渲染的精细程度非常有要求，比如光线、阴影等，那么你可以考虑下 babylon.js，毕竟这是款由微软前员工开发的游戏引擎啊……</p>
<p>这些基于 WebGL 的渲染方法，有一个共性的难题是如何交互，比如 hover, click 效果如何实现。其实在 Web AR 中交互非常局限：如果是桌面设备即电脑，和浏览网页的交互差不多，有 hover, click, drag 拖拽等；如果用的是移动设备，即手机、平板，则可能有 zoom 的交互（这里多嘴一句，其实移动 AR 中，应该尽量避免手指去 zoom 的交互，而应该引导用户用移近或移远设备来进行放大缩小）。这些实现起来要依赖于 <a href="https://en.wikipedia.org/wiki/Ray_casting" target="_blank" rel="external">光线投射算法 Ray casting</a> 方法。Three.js 直接提供了 <a href="https://threejs.org/docs/#api/core/Raycaster" target="_blank" rel="external">Raycaster</a> 类供实现 ray casting 算法。其实原理很简单，就是摄像头（这里的摄像头不是指手机的摄像头，而是你渲染时的 Camera，可以参考 Three.js 中的 <a href="https://threejs.org/docs/#api/cameras/Camera" target="_blank" rel="external">Camera</a>）视作视点，与你在屏幕上触碰的点坐标连城一条射线，看这条射线与你视图中哪些物体相交。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/7943693-31d57896a4fdf5dd.jpg" alt="Ray casting 算法"></p>
<p>这一节主要讲了渲染与交互，事实上在实现 AR 的时候，识别追踪和渲染交互是同时进行的，如何给用户更好、更流畅的体验是现在 Web AR 的又一大难题。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能是很多人关心的问题。目前浏览器的算力确实还不足以与客户端去媲美，但较之前也有了巨大的提升。识别和追踪本质上是像素级的计算，对算力的要求都很高，因此 maker-based 的 AR 定位效率通常比 makerless 的要高很多。此外，计算机视觉算法的效率对性能影响也很大，比如人脸识别目前较其他识别要成熟很多，所以人脸识别的算法在 Web 前端运行还算流畅。</p>
<p>提升性能的方法有很多种，大家一般会先想到用 WebGL 调用 GPU 加速，其次会想到用 Web Worker，WebAssembly。前两者我都试过，把纯计算的代码移到 WebGL 的 shader 或 Web Worker 里，这两者虽然都是加速计算，但适用场景不同。shader 可以用于加速<strong>只和渲染（重绘）有关的代码</strong>，无关渲染的代码放入 shader 中反而会造成重复计算。Web Worker 适用于事先计算或实时性要求不高的代码，如布局算法。WebAssembly 我还没在做 AR 的时候用过，还有一个库 <a href="https://github.com/gpujs/gpu.js" target="_blank" rel="external">gpu.js</a>也没试过，希望有大神试过之后告诉我有什么效果。</p>
<p>还有一种变相“提升”性能的方法是用滤波算法（比如<a href="https://zh.wikipedia.org/zh-hans/卡尔曼滤波" target="_blank" rel="external">卡尔曼滤波</a>）将卡顿降到更小，让用户从视觉感受上似乎更流畅。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>现在 Web AR 大潮刚刚开始，有很多高地需要人去攻克，比如光照估计、性能优化等，希望有兴趣的同学可以积极参与进来。而且 Web 前端无论是技术还是人口都发展迅速，充满了无限可能，有限的只是你的想象力。我很久之前做了个<a href="https://github.com/geekplux/AR-AI-VIS-demo" target="_blank" rel="external">人脸识别 + AR 的小 demo</a>，在 GitHub 上 <a href="https://github.com/geekplux/AR-AI-VIS-demo" target="_blank" rel="external">https://github.com/geekplux/AR-AI-VIS-demo</a>，大家可以玩玩，其实就几行代码。下一篇可能会写写 Web 前端做人脸识别相关的文章，感觉又给自己挖了个大坑，希望我的拖延症早日治好。</p>
<h2 id="附录：AR-开发技术"><a href="#附录：AR-开发技术" class="headerlink" title="附录：AR 开发技术"></a>附录：AR 开发技术</h2><p>参考文献 [2] 中曾总结了当时所有的 AR 开发技术，如下表:</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/Screen%20Shot%202018-01-18%20at%2001.17.58.png" alt="AR 开发技术"></p>
<p>这张表将 AR 开发工具分成了四类，分别罗列出来。其实目前大多的 AR 开发都是用 Unity 去做的，很多第三方 SDK 也都是先集成到 Unity 上，再由 Unity 输出到对应设备所需的格式。表中的 <a href="https://www.vuforia.com/" target="_blank" rel="external">Vuforia</a> 据我观察是目前用的最多的第三方 SDK。<strong><a href="https://www.artoolkit.org/" target="_blank" rel="external">ARToolKit</a> 则在 Web 前端和移动端用的很多</strong>，它的开源版是基于标记的 (Marker-based)，也提供机器学习的训练方法，让你可以将任意图片训练成 Marker。另外由于这张表是 2015 年的，当时苹果公司的 <a href="https://developer.apple.com/arkit/" target="_blank" rel="external">ARKit</a> 和谷歌的 <a href="https://developers.google.com/ar/" target="_blank" rel="external">ARCore</a> 这 2 个 SDK 还没有横空出世，可以将其归到表中的第三行。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li>[1] Azuma R T. A survey of augmented reality[J]. Presence Teleoperators &amp; Virtual Environments, 1997, 6(4): 355-385</li>
<li>[2] Billinghurst M, Clark A, Lee G. A survey of augmented reality[J]. Foundations and Trends in Human-Computer Interaction, 2015, 8(2-3): 73-272</li>
<li>[3] Zhou F, Duh B L, Billinghurst M. Trends in augmented reality tracking, interaction and display: a review of ten years of ISMAR[C] //Proceedings of the 7th IEEE/ACM International Symposium on Mixed and Augmented Reality. Washington: IEEE Computer Society Press, 2008: 193-202</li>
<li>[4] Rolland J P, Fuchs H. Optical versus video see-through head-mounted displays in medical visualization[M]. Cambridge: MIT Press, 2000, 9: 287-309</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文作者 &lt;a href=&quot;http://geekplux.com/&quot;&gt;GeekPlux&lt;/a&gt;，首发于&lt;a href=&quot;https://qianduan.group/posts/5a5f89cb0cf6b624d2239c65&quot; target=&quot;
    
    </summary>
    
      <category term="Web" scheme="http://geekplux.com/categories/Web/"/>
    
      <category term="Augmented Reality" scheme="http://geekplux.com/categories/Web/Augmented-Reality/"/>
    
    
      <category term="Web" scheme="http://geekplux.com/tags/Web/"/>
    
      <category term="WebGL" scheme="http://geekplux.com/tags/WebGL/"/>
    
      <category term="three.js" scheme="http://geekplux.com/tags/three-js/"/>
    
      <category term="AR" scheme="http://geekplux.com/tags/AR/"/>
    
      <category term="增强现实" scheme="http://geekplux.com/tags/%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E/"/>
    
      <category term="前端" scheme="http://geekplux.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>参加 Google Summer of Code 的体验</title>
    <link href="http://geekplux.com/2018/01/07/experience-of-gsoc-google-summer-of-code.html"/>
    <id>http://geekplux.com/2018/01/07/experience-of-gsoc-google-summer-of-code.html</id>
    <published>2018-01-07T08:13:23.000Z</published>
    <updated>2018-01-09T15:35:07.774Z</updated>
    
    <content type="html"><![CDATA[<p>Google Summer of Code （简称 GSoC）中文我叫它「谷歌编程夏令营」，是一年一度谷歌组织的类似暑期实习的编程活动。2018 年的申请马上就要开始了，在此我分享一下我参加 2017 年 GSoC 的体验。</p>
<h2 id="什么是-Google-Summer-of-Code？它值得参加么？"><a href="#什么是-Google-Summer-of-Code？它值得参加么？" class="headerlink" title="什么是 Google Summer of Code？它值得参加么？"></a>什么是 Google Summer of Code？它值得参加么？</h2><p>这个问题可以参考<a href="https://zhuanlan.zhihu.com/p/27330699" target="_blank" rel="external">Google 编程之夏(GSoC)：海量优质项目，丰厚报酬，你竟然还不知道？</a>这篇文章，里面介绍的非常详细，还客观的论述了为什么 GSoC 值得参加。不过在此我还是简单科普一下：</p>
<p>简言之，<strong>GSoC 是一年一度谷歌组织的、全球性的学生编程活动。学生利用暑假时间给开源社区贡献代码，谷歌支付报酬给学生</strong>。</p>
<p>将 GSoC 的特点提炼一下就是：</p>
<ul>
<li><strong>针对学生</strong>。只有学生身份才能申请参加（包括本科、硕士、博士）</li>
<li><strong>一年一度</strong>。每年都能申请，3 月末开始（建议早点开始套磁）</li>
<li><strong>全球性</strong>。你可能会和世界各地的学生一起工作</li>
<li><strong>开源社区</strong>。你是为开源社区贡献代码，大部分组织在 GitHub 上，所以你的贡献都是开源的，谁都能看到</li>
<li><strong>暑假期间</strong>。6 月正式开始工作，到 9 月</li>
<li><strong>报酬</strong>。谷歌支付报酬，中国区为 3600 刀，比大厂实习工资都高</li>
<li><strong>远程工作</strong>。这点在刚才的概念介绍中没提到，你可以在你想呆的任何地方写代码，不用去办公室</li>
<li><strong>导师指导</strong>。每个项目会给你配一个导师，有的导师非常负责且是大牛，你可以跟他学到很多</li>
</ul>
<p>我相信这些点已经足够吸引一个在校学生了。</p>
<h2 id="GSoC-怎么申请？"><a href="#GSoC-怎么申请？" class="headerlink" title="GSoC 怎么申请？"></a>GSoC 怎么申请？</h2><p>这个问题参考<a href="https://zhuanlan.zhihu.com/p/27823910" target="_blank" rel="external">Google Summer of Code 学生申请指南</a>。其实很简单，就是一篇 proposal，通过就可以参加当年的 GSoC 了。其他的参考资料可以看 <a href="https://github.com/gsoc-cn/gsoc-cn" target="_blank" rel="external">gsoc-cn</a>。</p>
<h2 id="正文-参加-GSoC-的体验"><a href="#正文-参加-GSoC-的体验" class="headerlink" title="正文 - 参加 GSoC 的体验"></a>正文 - 参加 GSoC 的体验</h2><h3 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h3><p>我是在 2017 年的 2 月份开始关注当年的 GSoC 申请。虽然每年各组织是在 2 月末公布自己的项目，但它们组织内部会在 1 月份甚至更早就开始谋划今年 GSoC 的项目计划，而且一般会公布在组织的主页上。我当时搜索到一些已经公布的项目，筛选了 3 个和我技能相匹配并且自己也想参加的项目，直接发了邮件过去。自我介绍了一番，并把自己针对这个项目的简单想法阐述了一下，其中有一个项目的 mentor（导师）非常热情，来回几番交流也十分愉快，算是理清了这个组织在做什么，他们这个项目想达到的效果。另外两个只是回复了我邮件便直接索要我的 proposal 了。说实话在不了解项目需求的情况下很难写一篇令人满意的 proposal，所以我也对这两个项目没怎么上心。</p>
<p>GSoC 的流程是 2 月末公布项目 idea，3 月末学生申请，所以有 1 个月的时间准备。但是早起的鸟儿有虫吃，有的人是 1 月份或上一年的 12 月就开始给项目贡献 PR(pull request) 了，所以他们申请的优势相当大。我的建议是越早准备越好，因为邮件的沟通没有 IM 频繁，再加上时区问题，交流的时间跨度会拉的很长。</p>
<p>我当时由于自己在参与一个科研投稿项目，分身乏术，几乎对申请上 GSoC 不抱什么希望了。但是在申请 deadline 前的几天，那个之前和我频繁交流的导师来询问我的 proposal，他督促我赶紧提交一份，即使不完美，提交了总比放弃好。我被他鼓励之后，立马连夜赶了一份出来提交了，虽然写的简单草率，但也是达到了一份合格 proposal 的要求：把需求、自己的解决办法、时间规划都写清楚了。deadline 前一天导师还对我进行了视频面试，幸运的是最后通过了审核，在学生生涯的最后一年赶上了 GSoC 的末班车。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>虽然 GSoC 是针对学生的，但我们不能以学生的心态面对这件事，而应该抱以雇员的态度。申请通过后，5 月整个月是暖身期，你可以熟悉组织里代码的提交流程，和组织里其他人聊聊天吹吹水搞搞关系，和导师多沟通一下之后暑假里的时间安排。比如你暑假有两周想去旅游，可以把这两周的工作提前完成。所以参加 GSoC 很自由，但要负责。</p>
<p>主要的工作流程全在 GitHub 上完成，从提 issue，到最后的 Pull Request 和 Code Review，日常交流是用 IRC 和 Gitter，文档管理用 Google doc。我的导师是意大利人，除了带我，还要带 4 个人，分别来自印度、牙买加、瑞士和俄罗斯。大家时区不同，每天 IRC 里的 Good morning 出现在各个时段。聊天都用英语，都是书面交流，所以口语差也没关系。</p>
<p>6 月正式开工，当时我是要用 WebGL 去重写一个大概 2 万节点，10 万条边的图结构可视化项目，前期工作不算一马平川，但也算走的稳当。到了中期，如何在 WebGL 中做交互成了一大难题，到了后期则是性能的优化。最终到 9 月份的时候我在 proposal 中提到的差不多有 90% 完成了，除了性能问题还有待提高。</p>
<p>3 个月中，我除了参加 GSoC 还需要水一篇论文，所以时间特别紧张，几乎是两班倒。导师问我进度的时候就各种解释，然后加班加点赶进度。每个月底会有一次评估，导师会针对你这个月的表现来决定你能不能继续参加，我每次都是低空飘过。最后项目结束我觉得我可能没达到导师的预期，但也算完成了工作。虽然总体上我觉得不是很出色，不过导师在 final evaluation 还是写了不错的评价。所有的工作总结在我之前的博文<a href="http://geekplux.com/2017/08/26/netjsongraph-js-google-summer-code-gsoc-2017-summary.html">netjsongraph.js — Google Summer of Code (GSoC) 2017 summary</a>中。</p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><ul>
<li><strong>代码水平有所提高</strong>。我参加的项目当时我导师他对前端可能没我熟，不过对代码风格、commit message 规范的要求还是很高的，在邮件中曾不止一次强调。另外他还推荐书单让我们阅读，他认为编程有很多是非常核心的、稳定的和通用的，学这部分才是关键。</li>
<li><strong>对开源有了全新认识</strong>。之前可能觉得开源只是一些个人开发者或组织把自认为不错的代码公布出来供大家交流。参加 GSoC 之后才发现很多开源组织非常庞大，组织架构都很多层，有自己的一套工作流程和方式、俨然一家公司模样，有自己的盈利方式，甚至有自己的基金。它们的目标不止是开发者，还可能是国家的基础设施建设等。再从个人开发者的角度来说，你可能由于参加 GSoC 而更加热爱开源，因为你发现开源社区的人都非常的热心和认真。</li>
<li><strong>和不同国家人工作的沟通成本很高</strong>。一方面是因为时区问题，大部分沟通，延迟回复都没什么问题，但一旦你提的 issue 是个紧急的 bug，而他这时候却在睡觉时间就很尴尬。另一方面是语言问题，尽管大家都用英语，但水平参差不齐，习惯不一，很多时候得多说两三次互相才能彻底理解对方的意思。不过认识新朋友看他们的 Twitter 和 Instagram 还是很有意思的。</li>
<li><strong>学会包装自己</strong>。这方面我们隔壁的印度朋友简直是典范，纵观他们的 proposal 和最后的总结都写的非常「浮夸」，平时的交流，他们也是非常频繁，活跃在各个平台。他们不是语言上浮夸，是内心上认为自己确实做到了他们叙述的效果。总之其他国家的同学比我们都高调一点，也很抱团，所以我们还是要学习一个。</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>人生艰难，作为象牙塔里的学生都能感到压力。如果你想利用暑假的大好时光来增加一点人生的经验，GSoC 可能是你不可多得的机会。享受一线互联网公司实习的待遇还能在 GitHub 上刷经验值，何乐不为？最重要的是，这可能是你开启另一种生活方式的一个机会，也可能是改变你编程生涯的机会（有的人成了大型开源组织的 core team member），更是一个跳出你舒适区的机会。</p>
<p>我时常担心自己变成温水里的青蛙，所以非常期待人生中的各种际遇，也想要体验各种各样的生活，在此共勉，加油朋友！</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google Summer of Code （简称 GSoC）中文我叫它「谷歌编程夏令营」，是一年一度谷歌组织的类似暑期实习的编程活动。2018 年的申请马上就要开始了，在此我分享一下我参加 2017 年 GSoC 的体验。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Google-S
    
    </summary>
    
      <category term="Life" scheme="http://geekplux.com/categories/Life/"/>
    
    
      <category term="生活" scheme="http://geekplux.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Google Summer of Code" scheme="http://geekplux.com/tags/Google-Summer-of-Code/"/>
    
      <category term="GSoC" scheme="http://geekplux.com/tags/GSoC/"/>
    
      <category term="Experience" scheme="http://geekplux.com/tags/Experience/"/>
    
      <category term="体验" scheme="http://geekplux.com/tags/%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>netjsongraph.js – Google Summer of Code (GSoC) 2017 summary</title>
    <link href="http://geekplux.com/2017/08/26/netjsongraph-js-google-summer-code-gsoc-2017-summary.html"/>
    <id>http://geekplux.com/2017/08/26/netjsongraph-js-google-summer-code-gsoc-2017-summary.html</id>
    <published>2017-08-26T14:45:52.000Z</published>
    <updated>2018-01-07T14:46:49.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Posted in medium: <a href="https://medium.com/@GeekPlux/netjsongraph-js-google-summer-of-code-gsoc-2017-summary-b0239f4eb8a9" target="_blank" rel="external">https://medium.com/@GeekPlux/netjsongraph-js-google-summer-of-code-gsoc-2017-summary-b0239f4eb8a9</a></p>
</blockquote>
<p>Throughout the last three months, I was quite fortunate to work for <a href="https://freifunk.net/" target="_blank" rel="external">Freifunk</a> on <a href="https://github.com/netjson/netjsongraph.js" target="_blank" rel="external">netjsongraph.js</a> under the guidance of my mentor <a href="https://github.com/nemesisdesign" target="_blank" rel="external">Federico Capoano</a>. Thanks for this invaluable experience that I learned a lot of knowledge and use them in a practical project. Here is a summary of the work I have done during the Google Summer of Code (GSoC) 2017.</p>
<p><img src="http://ovad4r7yz.bkt.gdipper.com/gsocScreen%20Shot%202017-08-26%20at%2017.27.46.png" alt="Google Summer of Code project page"></p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p><a href="https://github.com/netjson/netjsongraph.js" target="_blank" rel="external">netjsongraph.js</a> is a visualization library for <a href="http://netjson.org/docs/what.html#what-is-netjson" target="_blank" rel="external">NetJSON</a>, a network topology data format. The main goal of <a href="https://github.com/netjson/netjsongraph.js" target="_blank" rel="external">netjsongraph.js</a> may be concluded in below three lines (more details you can see in <a href="https://blog.freifunk.net/2017/05/30/gsoc-2017-netjsongraph-js-visualization-netjson-data/" target="_blank" rel="external">GSoC 2017-netjsongraph.js: visualization of NetJSON data</a>):</p>
<ul>
<li>Apply the modern front-end development tools and add tests workflow (<a href="https://github.com/netjson/netjsongraph.js/issues/1" target="_blank" rel="external">#1</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/45" target="_blank" rel="external">#45</a>)</li>
<li>Rewrite it with WebGL (<a href="https://github.com/netjson/netjsongraph.js/issues/11" target="_blank" rel="external">#11</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/29" target="_blank" rel="external">#29</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/39" target="_blank" rel="external">#39</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/42" target="_blank" rel="external">#42</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/47" target="_blank" rel="external">#47</a>)</li>
<li>Improve the performance (<a href="https://github.com/netjson/netjsongraph.js/issues/41" target="_blank" rel="external">#41</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/44" target="_blank" rel="external">#44</a>, <a href="https://github.com/netjson/netjsongraph.js/issues/46" target="_blank" rel="external">#46</a>)</li>
</ul>
<h2 id="Achievement"><a href="#Achievement" class="headerlink" title="Achievement"></a>Achievement</h2><blockquote>
<ul>
<li><h5 id="Github-Repository-https-github-com-netjson-netjsongraph-js"><a href="#Github-Repository-https-github-com-netjson-netjsongraph-js" class="headerlink" title="Github Repository : https://github.com/netjson/netjsongraph.js"></a>Github Repository : <a href="https://github.com/netjson/netjsongraph.js" target="_blank" rel="external">https://github.com/netjson/netjsongraph.js</a></h5></li>
<li><h5 id="Examples-on-GitHub-pages-https-netjson-github-io-netjsongraph-js"><a href="#Examples-on-GitHub-pages-https-netjson-github-io-netjsongraph-js" class="headerlink" title="Examples on GitHub pages: https://netjson.github.io/netjsongraph.js/"></a>Examples on GitHub pages: <a href="https://netjson.github.io/netjsongraph.js/" target="_blank" rel="external">https://netjson.github.io/netjsongraph.js/</a></h5></li>
</ul>
</blockquote>
<p>You can browse all examples on GitHub pages. Some screen shots of the application:</p>
<p><img src="http://ovad4r7yz.bkt.gdipper.com/Artboard%201.png" alt="basic example"></p>
<p><img src="http://ovad4r7yz.bkt.gdipper.com/Screen%20Shot%202017-08-26%20at%2017.33.36.png" alt="performance example"></p>
<p>The force-directed layout is usually used to visualize network data. It offers insights on the relationships between nodes and links. The previous version of <a href="https://github.com/netjson/netjsongraph.js" target="_blank" rel="external">netjsongraph.js</a> is implemented by <a href="https://d3js.org/" target="_blank" rel="external">d3</a> and it’s rendered using SVG. It would be very slow if there were thousands or ten of thousands nodes or links. So I have to embrace the WebGL speeded up by GPU to have a better performance.</p>
<p>I have recorded my work in the blog every milestone:</p>
<ul>
<li><a href="https://blog.freifunk.net/2017/06/29/gsoc-2017-netjsongraph-js-milestone-1/" target="_blank" rel="external">GSoC 2017-netjsongraph.js milestone 1</a></li>
<li><a href="https://blog.freifunk.net/2017/07/26/gsoc-2017-netjsongraph-js-milestone-2/" target="_blank" rel="external">GSoC 2017-netjsongraph.js milestone 2</a></li>
</ul>
<p><em>BTW, It’s a great management method to make members submit weekly reports and blog posts in <a href="https://freifunk.net/" target="_blank" rel="external">Freifunk</a>.</em></p>
<p>During the three months, there have been <strong>116 commits</strong> from me. I created a big Pull Request include them:</p>
<p><img src="http://ovad4r7yz.bkt.gdipper.com/Screen%20Shot%202017-08-26%20at%2016.28.07.png" alt="netjsongraph.js #48"></p>
<p><img src="http://ovad4r7yz.bkt.gdipper.com/Screen%20Shot%202017-08-26%20at%2016.26.46.png" alt="netjsongraph.js project panels"></p>
<p>Almost all goals have achieved:</p>
<ul>
<li>Published a minor version</li>
<li>Improved development workflow</li>
<li>Tests Added</li>
<li>Refactored visualization by <a href="https://threejs.org/" target="_blank" rel="external">Three.js</a> and <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a></li>
<li>Added more interaction like hover (show nodes tooltips), click (show nodes or links information panel), pan and zoom</li>
<li>Improved performance</li>
</ul>
<p>Especially on performance aspect, it runs efficiently on Chrome reached <strong>60FPS</strong> under <em>5k nodes and 10k links</em>. And if you don’t wanna animation, you can choose the static rendering layout.</p>
<h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>I also encounter some challenges I never met before.</p>
<h4 id="Event-binding-and-handling"><a href="#Event-binding-and-handling" class="headerlink" title="Event binding and handling"></a>Event binding and handling</h4><p>As you know, WebGL renders all objects in one canvas tag. How to bind events on every geometry? You should use the <a href="https://en.wikipedia.org/wiki/Ray_casting" target="_blank" rel="external">Ray casting</a>. Raycasting is used for mouse picking (working out what objects in the 3d space the mouse is over) amongst other things. So you can know which geometry your mouse over and add some interaction effect.</p>
<p>There are thousands of objects and every object has several events you should handle, I had to develop an event controller to manage it.</p>
<h4 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h4><p>The bottleneck in this visualizer is performance(<a href="https://github.com/netjson/netjsongraph.js/issues/41" target="_blank" rel="external">#41</a>). I tried many methods to improve it include:</p>
<h5 id="Reuse-geometry-and-material"><a href="#Reuse-geometry-and-material" class="headerlink" title="Reuse geometry and material"></a>Reuse geometry and material</h5><p>However, the color of every node is different and the one link should highlight itself when it hovered, so the material should be independent and can not use in common.</p>
<h5 id="Combine-the-mesh"><a href="#Combine-the-mesh" class="headerlink" title="Combine the mesh"></a>Combine the mesh</h5><p>Same problem with above. It’s not flexible to combine them to one mesh, different nodes and links should have different positions.</p>
<h5 id="Static-rendering"><a href="#Static-rendering" class="headerlink" title="Static rendering"></a>Static rendering</h5><p>Make calculation before rendering, so there is no animation and repaint.</p>
<h5 id="Using-Web-Worker"><a href="#Using-Web-Worker" class="headerlink" title="Using Web Worker"></a>Using Web Worker</h5><p>Web Workers is a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. So put static layout calculation into it will be efficient.</p>
<h4 id="Force-directed-algorithm"><a href="#Force-directed-algorithm" class="headerlink" title="Force-directed algorithm"></a>Force-directed algorithm</h4><p>There are different complexity and cost in the different force-directed algorithm. The <a href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0098679" target="_blank" rel="external">Force-Atlas2 algorithm</a> has some benefits over the force layout implemented in <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a>. So current version may be refactored by an advanced algorithm in the future.</p>
<h2 id="What-is-left-to-be-done"><a href="#What-is-left-to-be-done" class="headerlink" title="What is left to be done"></a>What is left to be done</h2><ul>
<li>Add optional geographic map (<a href="https://github.com/netjson/netjsongraph.js/issues/40" target="_blank" rel="external">#40</a>)</li>
<li>Using Force-Atlas2 algorithm</li>
</ul>
<p>More interactions and features should be added, and performance may be optimized by using new algorithm. I’d like to continue developing this project after GSoC.</p>
<p>In the end, thanks for the great patience and guidance from my mentors. Thanks for Google to provide me with this rare chance to contribute to an open source community together with awesome members from all over the world. I really appreciate this invaluable experience accumulated this summer and I believe it will have the profound impact on my career and life.</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Posted in medium: &lt;a href=&quot;https://medium.com/@GeekPlux/netjsongraph-js-google-summer-of-code-gsoc-2017-summary-b0239f4eb8a9
    
    </summary>
    
      <category term="Code" scheme="http://geekplux.com/categories/Code/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Code/Visualization/"/>
    
      <category term="Life" scheme="http://geekplux.com/categories/Code/Visualization/Life/"/>
    
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Google Summer of Code" scheme="http://geekplux.com/tags/Google-Summer-of-Code/"/>
    
      <category term="GSoC" scheme="http://geekplux.com/tags/GSoC/"/>
    
  </entry>
  
  <entry>
    <title>如何在 GitHub 上获得数百 stars</title>
    <link href="http://geekplux.com/2017/07/20/how-to-get-hundreds-stars-on-github.html"/>
    <id>http://geekplux.com/2017/07/20/how-to-get-hundreds-stars-on-github.html</id>
    <published>2017-07-20T03:16:16.000Z</published>
    <updated>2017-12-29T08:13:33.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于「<a href="https://juejin.im/post/59701b61518825412f27a0b1" target="_blank" rel="external">掘金专栏</a>」，地址：<a href="https://juejin.im/post/59701b61518825412f27a0b1" target="_blank" rel="external">https://juejin.im/post/59701b61518825412f27a0b1</a>。<br>本文写在 <a href="https://markvis.js.org" target="_blank" rel="external">markvis</a> 发布后的一周，总结了在推广个人项目方面的一些经验。阅读时长 10 分钟。</p>
</blockquote>
<p>每个程序员都幻想过自己的代码运行在千家万户的电脑上，但如何让你的项目获得更多的关注却少有人去思考。我们把注意力放在对代码的钻研、对技术的提升，却少有人关注如何吸引别人参与你的项目。一个人的力量总是有限的，尤其是在开源社区，越多的人参与就意味着你的项目有越多的可能性。</p>
<p>我的业余小项目 <a href="https://markvis.js.org" target="_blank" rel="external">markvis</a>(<a href="https://markvis.js.org" target="_blank" rel="external">https://markvis.js.org</a>) 发布一天之后，在 GitHub 收获了 200 stars，爬上了 Trending 榜前十，现在一周过去已经近 1000 stars。虽然这不算什么大的成就，但让我不得不重新思考<strong>推广</strong>的意义。</p>
<p><img src="https://i.loli.net/2017/07/20/597019565f3e0.png" alt="Trending TOP 10"></p>
<h2 id="对推广的偏见"><a href="#对推广的偏见" class="headerlink" title="对推广的偏见"></a>对推广的偏见</h2><p>一般人对推广都有或多或少的偏见，从我的个人经验来说大概来自两个方面：</p>
<p>一是受「酒香不怕巷子深」的影响，总认为只要是金子就会发光的。其实不然，道理很简单，你觉得你代码水平不错，但跟你同水平的程序员肯定不止你一个，如何让别人更加青睐于你，你需要的是曝光率，你需要把你自己的真实水平展现出来，你需要告诉别人你的实力，而不是等别人去挖掘。这个社会竞争太激烈了，尤其是在我们可爱的程序员界。</p>
<p>二是总把推广和低级的营销混为一谈，甚至把推广当成一个贬义词。我之前对推广的偏见主要来自于此，我总觉得推广和那些无脑发小广告的没什么两样。然而，真正的推广应该是在散播价值，让别人知道这个东西的存在，给别人提供了解的渠道。当然这得站在你项目是有价值的基础上，而不是空中楼阁就到处招摇撞骗。</p>
<h2 id="如何推广"><a href="#如何推广" class="headerlink" title="如何推广"></a>如何推广</h2><p>一个吸引眼球的开源项目，我认为需要具备以下几个要素：</p>
<ul>
<li>一个还不错的 Logo 或优雅的主页</li>
<li>简短有力的 slogan</li>
<li>能在线试用</li>
<li>完善的文档</li>
</ul>
<p>前两点一般都会被人忽略，但其实非常重要。第一点很好理解，毕竟是<strong>看脸</strong>的时代。第二点，为什么很多企业花很大代价去设计朗朗上口的标语？因为希望在<strong>最短的时间内给别人留下最深的印象</strong>。第三点正所谓百闻不如一见，向别人传递自己的想法总是困难的，不如让他们自己使用一下，<strong>用过才能理解</strong>你到底做了什么伟大的事情。如果你的项目没办法在线试用，最好有一个 gif 或短视频来演示一遍。如果说前三点是包装，那最后一点则是必须做到的重中之重，接下来我们重点说一说。</p>
<p>README 毋庸置疑是你项目最重要的页面，如何让别人迅速了解你的项目，你需要用最简短的话说清楚三件事：</p>
<ul>
<li>你的项目是什么</li>
<li>为什么要创造它</li>
<li>如何使用它</li>
</ul>
<p>尤其是为什么，一定要说清楚。它解决了什么问题，使用它的必要性是什么，它做出了什么贡献等等。</p>
<p>我们可以从使用者的角度去想问题：每当我们考虑是否要用这个库的时候，都是先去看他的 README，了解清楚它到底做了什么，以及它的优势。接着再看看它有没有测试，issues 多不多，解决 issues 和代码更新的频率是多少，大概有多少人使用等等。这就引出了另一些决定你项目成败的小细节。</p>
<ul>
<li>良好的代码风格</li>
<li>必要的注释</li>
<li>测试</li>
<li>开源协议是否规范</li>
</ul>
<p>这些事情说大不大，说小也不小。我在发布 <a href="https://markvis.js.org" target="_blank" rel="external">markvis</a> 之前把这些都检查了几遍。在 README 里可以用 <a href="https://coveralls.io/" target="_blank" rel="external">coverall</a> 的 badge 来展示测试覆盖率，用 <a href="http://fossa.io/" target="_blank" rel="external">fossa</a> 来检测你的协议是否规范。</p>
<h2 id="项目打造"><a href="#项目打造" class="headerlink" title="项目打造"></a>项目打造</h2><p>不是任何项目经过推广都能成功，推广的重要性可能只要 10%，剩下的 90% 都取决于项目本身。一个有价值的项目我认为要满足下面几个要求：</p>
<ul>
<li>解决了一部分需求</li>
<li>项目完成度高</li>
<li>长期维护</li>
</ul>
<p>首先你要有明确的目的，你要解决的是一个什么问题。这个问题通常不是空想出来的，而是有真正需要的，大多数情况来自于我们自己的需求。我在做 markvis 之前，已经在思考如何让写作时的可视化更简单。正好当时读了一篇论文<a href="http://geekplux.com/2016/11/02/vega-lite-a-grammar-of-interactive-graphics.html">《Vega-Lite: A Grammar of Interactive Graphics》</a>，我发现只要用简单的 JSON 就可以生成一个交互丰富的图表，这给我做 markvis 提供了极大的灵感。尽管接下来在项目开发的时候遇到一些空难不得不暂时放弃用 vega-lite 的方案，但阅读相关论文让我有了做 markvis 的底气。</p>
<p>其次你需要完成你的项目。开坑不填坑是我们技术人的常态，往往是脑子一热开始写一个项目，写了不到一半遇到点困难或中间停顿了几天，就放弃了。开发 markvis 的时候我也是这样，看 commits 记录就知道我其实不到一年前就开始开发了，但是强大的拖延症生生的把我拖到现在。没有完成，功能残缺，bug 一堆，谁还敢用。</p>
<p>开源项目最难的是维护。知名项目 issues 多的处理不过来，不知名项目完全无人问津。最痛苦的是那种用的人不多，还又没人参与的项目，这就完全靠自己了。你要面对的可能是无理的需求或质疑，但收到感谢信的时候还是非常开心的。</p>
<h2 id="如何发布"><a href="#如何发布" class="headerlink" title="如何发布"></a>如何发布</h2><p>万事俱备只欠东风，发布也是关键。我们没必要开个发布会，但至少要抱着搞个大新闻的心态。一般情况下，如果你不想让人提前知道你在做的东西，你最好不要在完成之前 push 到 GitHub 上，你可以悄悄的在本地紧锣密鼓的开发。直到完成的那一天，你需要准备下面两样东西：</p>
<ul>
<li>发布（帖子）的标题</li>
<li>发布（帖子）的内容</li>
</ul>
<p>我们不要做标题党，但是也要在帖子标题上稍微下点功夫，最好能说清楚你要干嘛还又能让别人有点击的欲望。帖子的内容很重要，可以把你 README 上的话再精简一点，口语化一点。然后开始有策略的向各大网站发帖：</p>
<ul>
<li>Hacker News</li>
<li>reddit/r/javascript</li>
<li>ProductHunt</li>
<li>V2EX</li>
</ul>
<p>当时我对 <a href="https://markvis.js.org" target="_blank" rel="external">markvis</a> 没抱太大期望，也没有考虑国外的作息时间，一大早起来就只在前两个网站上提交了自己的帖子。Hacker News 的流量太大，帖子直接秒沉了，reddit 上迟迟不见反馈。当时可能美国的程序员兄弟刚下班，都去浪了，所以一直没啥动静，star 好像只有十几个。虽然我有点失望，但是没有放弃，因为周围的小伙伴说我做的东西还不错。于是我在午饭之前又去 ProductHunt 上厚颜无耻地提交了自己的项目。没想到当天就上榜了。于是 star 数开始不停的长，第二天上了 GitHub Trending 之后就涨得更快了，完全超出了预期。</p>
<p>除了上面的这些网站，如果你英语不错的话，可以直接向 DailyJS 提交自己的文章，也可以让 JavaScript Weekly 推荐，总之渠道多多，就看你的项目如何了。下面是我发布一周后的主页 Google Analytics，可以看出上周一共有 4.5k 的人来访，周四即我发布的第二天是人来的最多的一天，而且程序员果然都喜欢凌晨学习，哈哈。</p>
<p><img src="https://i.loli.net/2017/07/20/59701a4966871.png" alt=""><br><img src="https://i.loli.net/2017/07/20/59701a497b025.png" alt=""></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>有一些事我们不去做是因为我们对它有偏见，比如推广。有一些事我们做不好是因为我们没有认真思考该怎么做，比如推广。禁锢我们的不是技术手段，而是思维。这是我这次发布 <a href="https://markvis.js.org" target="_blank" rel="external">markvis</a> 得到的一些人生经验，共勉。欢迎新朋友来和我交流，我的博客是 <a href="http://geekplux.com">http://geekplux.com</a> ，会一点前端，懂一点数据可视化。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于「&lt;a href=&quot;https://juejin.im/post/59701b61518825412f27a0b1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;掘金专栏&lt;/a&gt;」，地址：&lt;a href=&quot;https:/
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
      <category term="Promotion" scheme="http://geekplux.com/categories/Thought/Promotion/"/>
    
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="Promotion" scheme="http://geekplux.com/tags/Promotion/"/>
    
      <category term="推广" scheme="http://geekplux.com/tags/%E6%8E%A8%E5%B9%BF/"/>
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Skill" scheme="http://geekplux.com/tags/Skill/"/>
    
      <category term="Markvis" scheme="http://geekplux.com/tags/Markvis/"/>
    
      <category term="Markdown" scheme="http://geekplux.com/tags/Markdown/"/>
    
      <category term="GitHub" scheme="http://geekplux.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Markvis - 在 markdown 中生成可视化图表</title>
    <link href="http://geekplux.com/2017/07/14/what-is-markvis-md.html"/>
    <id>http://geekplux.com/2017/07/14/what-is-markvis-md.html</id>
    <published>2017-07-14T12:56:40.000Z</published>
    <updated>2017-07-20T03:10:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于「GraphiCon图形控」公众号，微信号 GraphiCon，原文地址：<a href="http://t.cn/RKmrRn9" target="_blank" rel="external">http://t.cn/RKmrRn9</a></p>
</blockquote>
<p>今天在这里给大家分享一个 markdown-it 插件，能让你在markdown 中通过几行代码就生成一个可视化图表📊。</p>
<ul>
<li>项目主页： <a href="https://markvis.js.org/" target="_blank" rel="external">https://markvis.js.org/</a></li>
<li>在线编辑器体验一下： <a href="https://markvis-editor.js.org/" target="_blank" rel="external">https://markvis-editor.js.org/</a></li>
<li>源码： <a href="https://github.com/geekplux/markvis" target="_blank" rel="external">https://github.com/geekplux/markvis</a></li>
</ul>
<p><img src="https://i.loli.net/2017/07/14/59687d0c743bd.jpeg" alt="home"></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Markdown 现在被越来越多的人熟悉，它是一个标记语言，只要你在每句话之前加一些符号，编辑器就能自动排版。markdown-it 是一个 markdown 的解析器，易扩展，很多人给它写插件，比如有个插件是让它支持可爱的 emoji 表情。markvis 也是一个插件，通过两行代码就能生成条形图折线图等，如下图：</p>
<p><img src="https://i.loli.net/2017/07/13/5966c9acb6509.png" alt="preview"></p>
<h2 id="为什么要做这个工具"><a href="#为什么要做这个工具" class="headerlink" title="为什么要做这个工具"></a>为什么要做这个工具</h2><p>有时候写文章需要插入一些数据来增强说服力，但是单纯的数字又不直观，所以可视化图表是必须的。紧接着就会出现一个问题：如何把图表添加到文章中。通常的做法是用一些现成的工具生成图片，然后把图片贴到文章中。这样一来就非常繁琐，尤其是用markdown写作时你还得把图片先上传到一个图床中。另一方面，访客阅读文章时，图片的加载比网页元素肯定更耗时。一旦加载过慢就会给阅读造成非常不好的体验。</p>
<p>Markvis 相当于抓住了这个痛点，开发出了直接在 Markdown 中生成图表的插件，省去写作人员的很多步骤。</p>
<h2 id="Markvis-的优势"><a href="#Markvis-的优势" class="headerlink" title="Markvis 的优势"></a>Markvis 的优势</h2><p>Markvis 设计的语法简单，而且拥有非常灵活的 API。</p>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>短短一天，Markvis 已经在 GitHub 上收获了 300+ 的 star 数，并且成功挤上了 Trending 榜前 10，连 Producthunt 的盆友都夸，相信将来在开发和维护上会有不少的优势。</p>
<p><img src="https://i.loli.net/2017/07/14/59687cd46241d.png" alt="comment"></p>
<h3 id="自定义图表"><a href="#自定义图表" class="headerlink" title="自定义图表"></a>自定义图表</h3><p>Markvis 目前提供三种最常用的图表：<a href="https://github.com/geekplux/markvis-bar" target="_blank" rel="external">条形图</a>，<a href="https://github.com/geekplux/markvis-line" target="_blank" rel="external">折线图</a>和<a href="https://github.com/geekplux/markvis-pie" target="_blank" rel="external">饼状图</a> 的布局。但是请不要担心，你可以通过 API 来自定义新的图表。只要你会一点 d3，就都可以轻松开发出一个新的图表布局。D3 （<a href="https://d3js.org）" target="_blank" rel="external">https://d3js.org）</a> 是目前最流行的可视化前端库，让你可以自由操作 SVG 元素，生成各式各样的可视化结果。</p>
<h3 id="自定义是引擎"><a href="#自定义是引擎" class="headerlink" title="自定义是引擎"></a>自定义是引擎</h3><p>目前 Markvis 是用 d3 来做底层的渲染，但实际上你可以直接把渲染引擎换掉，换成你想要的，比如 Vega-Lite，Echart 等。Vega-Lite 是 2016 年 IEEE VIS 的 best paper，提出了一种高级可视化语法，能直接用简单的 json 转换成一个可视化图表，并带有丰富的交互操作。Markvis 的下一步开发计划就是将其整合进来，这样 markvis 支持的图表类型和交互就极大的丰富起来。Echart 是国内百度开发的一款可视化库，也非常简单易用。</p>
<p>刚才提到的 D3 和 Vega-lite 都来自同一个实验室——可视化界著名的华盛顿大学交互数据实验室，他们在可视化工具方面的探索非常超前。不过目前国内的可视化发展也是突飞猛进，像百度嗯 Echart，阿里的 DataV、G2 都是很赞的可视化库。欢迎感兴趣的小伙伴一起来学习可视化知识，开发有趣的可视化工具！</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>除了上文提到的优势，markvis 还可以慢慢对接所有主流的 markdown parser。或者给主流编辑器提供插件。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于「GraphiCon图形控」公众号，微信号 GraphiCon，原文地址：&lt;a href=&quot;http://t.cn/RKmrRn9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://t.cn/RKmrRn9&lt;/
    
    </summary>
    
      <category term="Tool" scheme="http://geekplux.com/categories/Tool/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Tool/Visualization/"/>
    
    
      <category term="Development" scheme="http://geekplux.com/tags/Development/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Markvis" scheme="http://geekplux.com/tags/Markvis/"/>
    
      <category term="Markdown" scheme="http://geekplux.com/tags/Markdown/"/>
    
      <category term="markdown-it" scheme="http://geekplux.com/tags/markdown-it/"/>
    
  </entry>
  
  <entry>
    <title>D3 force layout and WebGL integration</title>
    <link href="http://geekplux.com/2017/06/27/d3-force-and-webgl-integration.html"/>
    <id>http://geekplux.com/2017/06/27/d3-force-and-webgl-integration.html</id>
    <published>2017-06-27T11:57:37.000Z</published>
    <updated>2017-07-09T10:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>D3 是目前最流行的数据可视化库，WebGL 是目前 Web 端最快的绘制技术。由于性能问题的局限，将两者结合的尝试越来越多（如），本文将尝试用 <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">D3 的力导向图</a> 和 <a href="https://github.com/mrdoob/three.js/" target="_blank" rel="external">Three.js</a> 和 <a href="https://github.com/pixijs/pixi.js" target="_blank" rel="external">PixiJS</a> 结合。全文阅读完大概 5 分钟，因为你重点应该看<a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">代码</a>。</p>
</blockquote>
<p>做数据可视化时，必然会考虑<strong>性能</strong>的问题。早前数据可视化都是用 Qt 等 GUI，后来逐渐迁移到了迅猛发展的浏览器上展示，Web 的性能问题成了大多数可视化的局限，尤其是在三维可视化，或数据量特别大的时候。现在主流的 Web 可视化技术为三种：SVG、Canvas 和 WebGL，难易程度和性能如下图：</p>
<p><img src="https://ooo.0o0.ooo/2017/07/09/59610ee72e616.png" alt="Web visualization tech"></p>
<p>SVG 的优点很多，编辑简单，交互便捷，灵活性极高，业内成熟的可视化工具（如 d3）都是用的 SVG。但是每个 SVG 都是一个 DOM 元素，随着它的数量上来之后，交互开始慢的难以忍受。这是因为每当修改一个 DOM 对象，只要这个对象在文档里，接着在浏览器里就会发生两个动作，一个叫 <strong>Reflow（重排，就是重新排版）</strong>，另一个叫 <strong>Repaint（重绘，就是重新渲染页面）</strong>。这两个动作不一定都会发生，但如果被修改的 DOM 当前可见的话，那么就会先重排，后重绘。绘制性能上 canvas 和 SVG（DOM 元素）应该差不多，但前者可以省掉重排过程，因此性能更高。然而，WebGL 的性能更胜一筹，因为 WebGL 使用 GPU 加速渲染，GPU 在大规模计算方面有绝对优势（图像处理、深度学习都在用，显卡已经卖疯了）。例子：用 WebGL 绘制 200000 个点的动画(<a href="http://rickyreusser.com/smoothly-animating-points-with-regl/" target="_blank" rel="external">http://rickyreusser.com/smoothly-animating-points-with-regl/</a>)</p>
<p>WebGL 虽然威力无穷，但是写起来比较痛苦，画个三角形大致要 100 行代码。所以很多人对 WebGL 进行了封装。上面图中提到的两个 <a href="https://github.com/mrdoob/three.js/" target="_blank" rel="external">Three.js</a> 和 <a href="https://github.com/pixijs/pixi.js" target="_blank" rel="external">PixiJS</a> 是目前最流行的两款 WebGL 库，当然还有新兴的 <a href="https://github.com/regl-project/regl" target="_blank" rel="external">regl</a> 在今年的 <a href="https://openvisconf.com/" target="_blank" rel="external">OpenVis</a> 上大放异彩。本文尝试用前两者和 <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a> 结合（<a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">项目代码在此</a>），后面如果有时间的话，我会把使用 regl 和原生 WebGL 的例子也补充进去（我知道这是个 flag）。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先我们要知道什么是<strong>力导向图</strong>和如何使用 <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a>。d3 4.0 之后，作者将其模块化，force 这个模块是基于 <a href="https://en.wikipedia.org/wiki/Verlet_integration" target="_blank" rel="external">velocity Verlet</a> 实现了物理粒子之间的作用力的仿真，常用于网络或关系结构数据。即你把网络中的节点想象成一个个粒子，它们之间互相有作用力，所以不停的拉扯，直到趋于一个稳定状态，具体可以看我 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">demo</a> 中可视化出来的样子。</p>
<p><img src="https://ooo.0o0.ooo/2017/07/09/59610ee4d02d5.png" alt="Demo 效果图"></p>
<p>仔细看 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">demo</a> 中的源码可以发现，用 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo/blob/master/src/three.js" target="_blank" rel="external">three.js</a> 和用 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo/blob/master/src/pixi.js" target="_blank" rel="external">pixi.js</a> 实现起来非常类似，其中有关力导向图的关键代码是下面几句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> simulation = d3.forceSimulation() <span class="comment">// 创建一个作用力的仿真，但此时还没启动</span></div><div class="line">  .force(<span class="string">'link'</span>, d3.forceLink().id((d) =&gt; d.id)) <span class="comment">// 为边之间添加 Link 型作用力</span></div><div class="line">  .force(<span class="string">'charge'</span>, d3.forceManyBody()) <span class="comment">// 指定节点间的作用力类型为 Many-Body 型</span></div><div class="line">  .force(<span class="string">'center'</span>, d3.forceCenter(width / <span class="number">2</span>, height / <span class="number">2</span>)) <span class="comment">// Centering 作用力指定布局围绕的中心</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a> 提供了五种作用力，分别是 Centering、Collision、Links、Many-Body、Positioning。此时我们已经创建好带有各种力的仿真器了，接下来需要启动它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">simulation</div><div class="line">  .nodes(data.nodes) <span class="comment">// 根据 data.nodes 数组来计算点之间的作用力，相当于不停计算节点的 xy 坐标</span></div><div class="line">  .on(<span class="string">'tick'</span>, ticked) <span class="comment">// 每次 tick 调用 ticked</span></div><div class="line"></div><div class="line">simulation.force(<span class="string">'link'</span>)</div><div class="line">  .links(data.links) <span class="comment">// 根据 data.links 数据计算边之间的作用力</span></div></pre></td></tr></table></figure>
<p>至此一个力导向图的仿真就开始了，那么怎么把这些节点和边显示出来呢？让我们继续看源码，以 three.js 为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene()</div><div class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(<span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</div><div class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123;alpha: <span class="literal">true</span>&#125;)</div><div class="line">renderer.setSize(width, height)</div><div class="line">container.appendChild(renderer.domElement) <span class="comment">// container 这里是 document.body</span></div></pre></td></tr></table></figure>
<p>在 Three.js 中展示场景需要具备三要素：<strong>场景、照相机、渲染器</strong>。照相机就相当于我们的眼睛，它对着渲染好的场景就相当于把场景成像到了相机中，这里的照相机我们用的是平行投影相机，渲染器我们使用的是 WebGL 渲染器。设置好渲染器的大小，把它添加到页面的元素上，相当于添加了一个 <code>&lt;canvas&gt;</code> 元素。接下来，我们生成每个节点和边的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">data.nodes.forEach((node) =&gt; &#123;</div><div class="line">  node.geometry = <span class="keyword">new</span> THREE.CircleBufferGeometry(<span class="number">5</span>, <span class="number">32</span>)</div><div class="line">  node.material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; color: colour(node.id) &#125;)</div><div class="line">  node.circle = <span class="keyword">new</span> THREE.Mesh(node.geometry, node.material)</div><div class="line">  scene.add(node.circle)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">data.links.forEach((link) =&gt; &#123;</div><div class="line">  link.material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; color: <span class="number">0xAAAAAA</span> &#125;)</div><div class="line">  link.geometry = <span class="keyword">new</span> THREE.Geometry()</div><div class="line">  link.line = <span class="keyword">new</span> THREE.Line(link.geometry, link.material)</div><div class="line">  scene.add(link.line)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>套路都一样，都是先建一个几何体，然后设置材质的样式，添加到场景中就好了。接下来只要在刚才提到的 ticked 这个回调函数中把节点和边的坐标更新一下就好了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ticked</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  data.nodes.forEach((node) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> &#123; x, y, circle &#125; = node</div><div class="line">    circle.position.set(x, y, <span class="number">0</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  data.links.forEach((link) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> &#123; source, target, line &#125; = link</div><div class="line">    line.geometry.verticesNeedUpdate = <span class="literal">true</span></div><div class="line">    line.geometry.vertices[<span class="number">0</span>] = <span class="keyword">new</span> THREE.Vector3(source.x, source.y, <span class="number">-1</span>)</div><div class="line">    line.geometry.vertices[<span class="number">1</span>] = <span class="keyword">new</span> THREE.Vector3(target.x, target.y, <span class="number">-1</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  render(scene, camera)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是比想象的简单多了？如果以上有什么地方看不懂，说明你可能对 Three.js 不是很了解，不过没关系，它的文档写的很好，入门很快。希望这篇文章能给你带来一些帮助，做了点微小的贡献，很惭愧 :)</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;D3 是目前最流行的数据可视化库，WebGL 是目前 Web 端最快的绘制技术。由于性能问题的局限，将两者结合的尝试越来越多（如），本文将尝试用 &lt;a href=&quot;https://github.com/d3/d3-force/&quot; target=&quot;_
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Web" scheme="http://geekplux.com/tags/Web/"/>
    
      <category term="WebGL" scheme="http://geekplux.com/tags/WebGL/"/>
    
      <category term="three.js" scheme="http://geekplux.com/tags/three-js/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="尝试" scheme="http://geekplux.com/tags/%E5%B0%9D%E8%AF%95/"/>
    
      <category term="d3" scheme="http://geekplux.com/tags/d3/"/>
    
      <category term="pixi.js" scheme="http://geekplux.com/tags/pixi-js/"/>
    
      <category term="Google Summer of Code" scheme="http://geekplux.com/tags/Google-Summer-of-Code/"/>
    
  </entry>
  
  <entry>
    <title>文本数据可视化（下）——一图胜千言</title>
    <link href="http://geekplux.com/2017/06/26/text-data-visualization.html"/>
    <id>http://geekplux.com/2017/06/26/text-data-visualization.html</id>
    <published>2017-06-26T05:57:41.000Z</published>
    <updated>2017-07-09T10:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于：<a href="https://zhuanlan.zhihu.com/p/27449788" target="_blank" rel="external">GraphiCon 知乎专栏-文本数据可视化（下）——一图胜千言</a></p>
</blockquote>
<p>文字是传递信息最常用的载体。在当前这个信息爆炸的时代，人们接收信息的速度已经小于信息产生的速度，尤其是文本信息。当大段大段的文字摆在面前，已经很少有耐心去认真把它读完，经常是先找文中的图片来看。这一方面说明人们对图形的接受程度比枯燥的文字要高很多，另一方面说明人们急需一种更高效的信息接收方式，文本可视化正是解药良方。「一图胜千言」我们从小就有体会，教材里的解释图、自己笔记里总结的知识结构图，一直到现在经常用的思维导图等，其实都是简单、实用的文本可视化。本文将简单介绍文本可视化的基础概念，然后重点通过各类文本可视化的案例来阐述可视化之美（多图，不过为了学到知识这点流量不算什么）。</p>
<h2 id="为什么要文本数据可视化"><a href="#为什么要文本数据可视化" class="headerlink" title="为什么要文本数据可视化"></a>为什么要文本数据可视化</h2><p>虽然一般这种讲必要性的段落很多人都略过不看，虽然文本可视化的必要性大家用脚趾头估计都能想到，但我还是稍微说一说吧。文本可视化的作用有以下四点：</p>
<ol>
<li><strong>理解</strong> - 理解主旨</li>
<li><strong>组织</strong> - 组织、分类信息</li>
<li><strong>比较</strong> - 对比文档信息</li>
<li><strong>关联</strong> - 关联文本的 pattern 和其他信息</li>
</ol>
<p>简单来说就是让你更加直观迅速的获取、分析信息（所有可视化的作用都是这个）。举个例子，针对一篇文章，文本可视化能更快的告诉我们文章在讲什么；针对社交网络上的发言，文本可视化可以帮我们信息归类，情感分析；针对一个大新闻，文本可视化可以帮我们捋顺事情发展的脉络、每个人物的关系等等；针对一系列的文档，我们可以通过文本可视化来找到它们之间的联系等等。</p>
<p>一般来说，情报分析人员、网络内容分析人员、情感分析或文学研究者等相关职业更需要文本可视化。不过随着信息图（例如图 1）等的普及，越来越多的人已经接受并善用文本可视化了。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5932f80b2d468.jpg" alt="图 1：一幅叫你怎么做信息图的信息图"></p>
<h2 id="文本数据可视化的流程"><a href="#文本数据可视化的流程" class="headerlink" title="文本数据可视化的流程"></a>文本数据可视化的流程</h2><p>如图 2 所示，其实任何可视化的流程<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">[1]</a>都类似。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5932f85a02711.png" alt="图 2：文本可视化流程"></p>
<p>一般把对文本的理解需求分成三级：词汇级（Lexical Level）、语法级（Syntactic Level）和语义级（Semantic Level）。不同级的信息挖掘方法也不同，词汇级当然是用各类分词算法，语法级用一些句法分析算法，语义级用主题抽取算法<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">[2]</a>。以上这些都在第二步文本信息挖掘中进行，其中文本数据预处理是将无效数据过滤，提取有效词等；文本特征抽取是指提取文本的关键词、词频分布、语法级的实体信息、语义级的主题等；文本特征的度量是指在多种环境或多个数据源所抽取的文本特征进行深层分析，如相似性、文本聚类等。这里就简单笼统地说一下文本分析的基础方法，有兴趣的同学可以自行搜索学习，我们把重点放在可视化设计上。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933efa249cfe.png" alt="Wordcount[3] 统计了通常用的86800个单词"></p>
<h2 id="文本可视化类型"><a href="#文本可视化类型" class="headerlink" title="文本可视化类型"></a>文本可视化类型</h2><p>文本数据大致可分为三种：单文本、文档集合和时序文本数据。对应的文本可视化也可分为三类：</p>
<ul>
<li>文本内容的可视化</li>
<li>文本关系的可视化</li>
<li>文本多层面信息的可视化</li>
</ul>
<p>以下我们通过案例来一一介绍。</p>
<h2 id="文本内容可视化"><a href="#文本内容可视化" class="headerlink" title="文本内容可视化"></a>文本内容可视化</h2><p>上篇文章所说的标签云和 Wordle <a href="https://zhuanlan.zhihu.com/p/26306683" target="_blank" rel="external">[4]</a>是目前研究领域和 Web 上最受欢迎的文本内容可视化方法了，它们都是基于关键词的文本内容可视化。</p>
<h4 id="基于关键词的文本内容可视化"><a href="#基于关键词的文本内容可视化" class="headerlink" title="基于关键词的文本内容可视化"></a>基于关键词的文本内容可视化</h4><h5 id="DocuBurst"><a href="#DocuBurst" class="headerlink" title="DocuBurst"></a>DocuBurst</h5><p>文档散（DocuBurst [5]）也是基于关键词的文本可视化，不过它还通过径向布局体现了词的语义等级。如下图所示，外层的词是内层词的下义祠，颜色饱和度的深浅用来体现词频的高低。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031fe74aa3.png" alt=""></p>
<h5 id="Document-Cards"><a href="#Document-Cards" class="headerlink" title="Document Cards"></a>Document Cards</h5><p>文档卡片（Document Cards）[6]则是结合了文档中的关键词和关键图片进行可视化，布局在一张小卡片中。其中的关键图片是指采用智能算法抽取并根据颜色分类后的代表性图片。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933f0f44cf19.png" alt=""></p>
<h4 id="时序文本内容可视化"><a href="#时序文本内容可视化" class="headerlink" title="时序文本内容可视化"></a>时序文本内容可视化</h4><p>时序数据是指具有时间或顺序特性的文本，例如一篇小说故事情节的变化，或一个新闻事件随时间的演化。</p>
<h5 id="SparkClouds"><a href="#SparkClouds" class="headerlink" title="SparkClouds"></a>SparkClouds</h5><p>SparkClouds[7]是在标签云的基础上，在每个词下面增加了一条折线图，用以显示该词的词频随时间的演变。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933fed566376.png" alt="SparkCloud"></p>
<h5 id="ThemeRiver"><a href="#ThemeRiver" class="headerlink" title="ThemeRiver"></a>ThemeRiver</h5><p>主题河流（ThemeRiver）[8]是一种经典的时序文本可视化方法。光阴似水，用河流来隐喻时间的变化几乎所有人都能非常好地理解。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933f323e5d43.png" alt="ThemeRiver"></p>
<p>横轴表示时间，每一条不同颜色线条可视作一条河流，而每条河流则表示一个主题，河流的宽度代表其在当前时间点上的一个度量（如主题的强度）。这样既可以在宏观上看出多个主题的发展变化，又能看出在特定时间点上主题的分布。</p>
<h5 id="TIARA"><a href="#TIARA" class="headerlink" title="TIARA"></a>TIARA</h5><p>TIARA[9]结合了标签云，通过主题分析技术（latent dirichlet allocation，LDA），将文本关键词根据时间点放置在每条色带上，并用词的大小来表示关键词在该时刻出现的频率。因此用TIARA就可以帮助用户快速分析文本具体内容随时间变化的规律，而不是仅仅一个度量带变化。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/593409c1dbde1.png" alt="TIARA"></p>
<h5 id="TextFlow"><a href="#TextFlow" class="headerlink" title="TextFlow"></a>TextFlow</h5><p>TextFlow [10]也算是 ThemeRiver 的一种拓展，它不仅表达了主题的变化，还表达了各个主题随着时间的分裂与合并。如某个主题在某个时间分成了两个主题，或多个主题在某个时间合并成了一个主题。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/14/59412ad2d6548.png" alt="TextFlow"></p>
<h5 id="HistoryFlow"><a href="#HistoryFlow" class="headerlink" title="HistoryFlow"></a>HistoryFlow</h5><p>HistoryFlow [11]则主要研究文档内容随时间的变化。下图以维基百科一篇词条的更新为例，纵轴表示文章的版本更新时间点，每一种颜色代表一个作者，在同一个时间轴上色块代表相应的作者所贡献的文字块，并且色块的位置代表该文字块在文章中的顺序。所以纵览全图就可以轻易看出文章的修改。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/14/59412ad31e48b.png" alt="HistoryFlow"></p>
<h5 id="StoryFlow"><a href="#StoryFlow" class="headerlink" title="StoryFlow"></a>StoryFlow</h5><p>我们看电影或小说经常说到时间线、剧情线等，都能用 StoryFlow [12]来表示，它通过层次渲染的方式，生成一个 StoryLine 布局。每条线是一条人物线，当两人在剧情中有某种联系（同时出场或其他交集）时会在图中相交，横轴表示时间。</p>
<p>StoryFlow 还允许用户实时交互，包括捆绑操作、删除、移动以及直线化等等。视频演示非常精彩，需科学上网：<a href="https://www.youtube.com/watch?v=yoq82mC30Iw" target="_blank" rel="external">https://www.youtube.com/watch?v=yoq82mC30Iw</a></p>
<p><img src="https://ooo.0o0.ooo/2017/06/14/59412ad2c4740.png" alt="StoryFlow"></p>
<h4 id="文本特征分布模式可视化"><a href="#文本特征分布模式可视化" class="headerlink" title="文本特征分布模式可视化"></a>文本特征分布模式可视化</h4><p>可视化也能很好的表现文本特征。</p>
<h5 id="TextArc"><a href="#TextArc" class="headerlink" title="TextArc"></a>TextArc</h5><p>TextArc [13]用来可视化一个文档中的词频和词的分布情况。整个文档用一条螺线表示，文档的句子按文字的组织顺序布局在螺线上，螺线包围着的是文档中出现的单词，每个单词的位置由其在文本中的频率和出现位置决定，饱和度用来映射词频。所以全局出现频率越高的词越靠近中心，而局部出现频率越高的词越靠近其相应的螺线区域。选中某个单词后，自动用射线关联到它在文中出现的位置。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e89856682.png" alt="Textarc"></p>
<h5 id="Literature-Fingerprinting"><a href="#Literature-Fingerprinting" class="headerlink" title="Literature Fingerprinting"></a>Literature Fingerprinting</h5><p>文献指纹（Literature Fingerprinting）[14]是体现全文特征分布的一项工作。一个像素块代表一段文本，一组像素块代表一本书。颜色映射的是文本特征，下图中是句子的平均长度。从图中明显看出两人的写作风格迥异。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e897d8434.png" alt="Literature Fingerprinting"></p>
<h4 id="情感分析可视化"><a href="#情感分析可视化" class="headerlink" title="情感分析可视化"></a>情感分析可视化</h4><p>情感分析是指从文本中挖掘出心情、喜好、感觉等主观信息。现在人们把各类社交网络当作感情、观点的出口，所以分析这类文本就能掌握人们对于一个事件的观点或情感的发展。下图是基于矩阵视图的客户反馈信息的可视化工作[15]，其中的行是指文本（用户观点）的载体，列是用户的评价，颜色表达的是用户评价的倾向程度，红色代表消极，蓝色代表积极，每个方格内的小格子代表用户评价的人数，评价人数越多小格子越大。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e897ebec4.png" alt="情感分析"></p>
<h2 id="文本关系可视化"><a href="#文本关系可视化" class="headerlink" title="文本关系可视化"></a>文本关系可视化</h2><p>顾名思义，文本关系可视化研究的是文本或文档集合中的关系信息，比如文本的相似性、互相引用的情况、链接等。说到关系布局，一般都是树或图。</p>
<h4 id="文本内容关系可视化"><a href="#文本内容关系可视化" class="headerlink" title="文本内容关系可视化"></a>文本内容关系可视化</h4><h5 id="Word-Tree"><a href="#Word-Tree" class="headerlink" title="Word Tree"></a>Word Tree</h5><p>单词树（Word Tree）[16]很好理解，把文本中的句子按树形结构布局，可以很好的看出一个单词在文本中出现的频率和单词前后的联系。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e8980de0c.png" alt="Word Tree.png"></p>
<h5 id="Phrase-Nets"><a href="#Phrase-Nets" class="headerlink" title="Phrase Nets"></a>Phrase Nets</h5><p>短语网络（Phrase Nets）[17]是经典的力导向图结构，图中的节点是从文本中挖掘出的词汇级或语法级的语义单元，边代表语义单元的联系，边的方向即短语的方向，边的宽度是短语在文本中出现的频率。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e897b8220.png" alt="Phrase Nets.png"></p>
<h5 id="NewsMap"><a href="#NewsMap" class="headerlink" title="NewsMap"></a>NewsMap</h5><p>TreeMap 也是一种经典的可视化关系布局。NewsMap 就是基于 TreeMap 展示新闻，颜色用于区分新闻类型。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e89847efb.png" alt="Newsmap.png"></p>
<h4 id="文档集合关系可视化"><a href="#文档集合关系可视化" class="headerlink" title="文档集合关系可视化"></a>文档集合关系可视化</h4><p>文档数量到一定量的时候，再针对文本做可视化就不现实了，所以通常是对单个文档定义一个特征向量，利用向量空间模型计算文档间的相似性，并采用相应的投影技术呈现文档集合的关系。</p>
<h5 id="Galaxy-View"><a href="#Galaxy-View" class="headerlink" title="Galaxy View"></a>Galaxy View</h5><p>星系图（Galaxy View）[18]把一篇文档比作一颗星星，通过投影的方法把所有文档按照其主题的相似性投影为二维平面的点集，星星离的越近则代表文档越相似，因此一个星团可以非常直观地看出文档主题的紧凑和离散。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941f41b47937.png" alt="Galaxy View"></p>
<h5 id="ThemeScape"><a href="#ThemeScape" class="headerlink" title="ThemeScape"></a>ThemeScape</h5><p>主题地貌（ThemeScape）[18]是对星系图的改进。地图中的等高线我相信大家都理解，把等高线加入投影的二维平面中，文档相似性相同的放在一个等高线内，再用颜色来编码文本分布的密集程度，把二维平面背景变成一幅地图，这样就把刚才星系图中的星团变成了一座座山丘。文档越相似，则分布约密集，这座山峰就越高，是不是一目了然？</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941f478ec87d.png" alt="ThemeScape"></p>
<h5 id="Jigsaw"><a href="#Jigsaw" class="headerlink" title="Jigsaw"></a>Jigsaw</h5><p>Jigsaw [19]通过提供多种视图让用户交互分析文档间的关系。最下面是文档视图，里面是单个文档的内容，最上面列表图中每一行是文档中的一个实体，连线代表实体间的关系。中间部分，左面是一副节点-链接图，白色节点表示一篇文档，其他节点是文档中的实体，链接同样代表联系；右面的散点图中，一个菱形代表两个实体的联系。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941f45268950.png" alt="Jigsaw"></p>
<h2 id="文本多层面信息可视化"><a href="#文本多层面信息可视化" class="headerlink" title="文本多层面信息可视化"></a>文本多层面信息可视化</h2><p>多层面或多维度是指从多个角度或提取多种特征对文本集合分析。</p>
<h5 id="FaceAtlas"><a href="#FaceAtlas" class="headerlink" title="FaceAtlas"></a>FaceAtlas</h5><p>FaceAtlas [20]结合了气泡集和节点-链接图两种视图，用于表达文本各层面信息内部和外部的关联。每个节点表示一个实体，用 KDE 方法刻画出气泡图的轮廓，然后用线将同一层面的实体链接起来，一种颜色代表一种实体。下图是基于医疗健康文档，展示了病名、病因、症状、诊断方案等多层面的信息，两团分别代表糖尿病1号和2号，连线是指他俩之间的并发症。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941fc7386d50.png" alt="faceatlas.png"></p>
<h5 id="Parallel-Tag-Clouds"><a href="#Parallel-Tag-Clouds" class="headerlink" title="Parallel Tag Clouds"></a>Parallel Tag Clouds</h5><p>平行标签云（Parallel Tag Clouds）[21]结合了平行坐标（该视图在多维数据可视化中经常使用）和标签云视图。每一列是一个层面的标签云，然后连接的折线展现了选中标签在多个层面的分布。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941fc7fd281e.png" alt="parallel_tag_clouds.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天带大家看了这么多图，相信大家一定眼花缭乱了。要理解文本数据可视化，就要先了解文本数据的特点，如何从文本中挖掘出你想要的信息，如何设计数据结构，最后再如何映射出实用又美观的视图都是你需要思考的问题。目前文本可视分析已经开始运用在各行各业，直观的交互将人类的智慧引入到数据分析的过程中，帮助我们从浩瀚的文字中跳脱出来，避免一叶障目。希望我的文章能给大家带来一些微小的帮助。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1] <a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">数据可视化基础——可视化流程</a></li>
<li>[2] <a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[3] <a href="http://www.wordcount.org/" target="_blank" rel="external">WordCount</a></li>
<li>[4] <a href="https://zhuanlan.zhihu.com/p/26306683" target="_blank" rel="external">文本数据可视化（上）——从 Wordle 谈起</a></li>
<li>[5] Collins C, Carpendale S, Penn G. Docuburst: Visualizing document content using language structure[C]//Computer graphics forum. Blackwell Publishing Ltd, 2009, 28(3): 1039-1046.</li>
<li>[6] Strobelt H, Oelke D, Rohrdantz C, et al. Document cards: A top trumps visualization for documents[J]. IEEE Transactions on Visualization and Computer Graphics, 2009, 15(6): 1145-1152.</li>
<li>[7] Lee B, Riche N H, Karlson A K, et al. Sparkclouds: Visualizing trends in tag clouds[J]. IEEE transactions on visualization and computer graphics, 2010, 16(6): 1182-1189.</li>
<li>[8] Havre S, Hetzler E, Whitney P, et al. Themeriver: Visualizing thematic changes in large document collections[J]. IEEE transactions on visualization and computer graphics, 2002, 8(1): 9-20.</li>
<li>[9] Wei F, Liu S, Song Y, et al. Tiara: a visual exploratory text analytic system[C]//Proceedings of the 16th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2010: 153-162.</li>
<li>[10] Cui W, Liu S, Tan L, et al. Textflow: Towards better understanding of evolving topics in text[J]. IEEE transactions on visualization and computer graphics, 2011, 17(12): 2412-2421.</li>
<li>[11] Wattenberg M, Viégas F B. Historyflow: visualizing dynamic, evolving documents and the interactions of multiple collaborating authors, A preliminary report[J]. IBM Research, Collaborative User Experience research group, 2003.</li>
<li>[12] Liu S, Wu Y, Wei E, et al. Storyflow: Tracking the evolution of stories[J]. IEEE Transactions on Visualization and Computer Graphics, 2013, 19(12): 2436-2445.</li>
<li>[13] Paley W B. TextArc: Showing word frequency and distribution in text[C]//Poster presented at IEEE Symposium on Information Visualization. 2002, 2002.</li>
<li>[14] Keim D A, Oelke D. Literature fingerprinting: A new method for visual literary analysis[C]//Visual Analytics Science and Technology, 2007. VAST 2007. IEEE Symposium on. IEEE, 2007: 115-122.</li>
<li>[15] Oelke D, Hao M, Rohrdantz C, et al. Visual opinion analysis of customer feedback data[C]//Visual Analytics Science and Technology, 2009. VAST 2009. IEEE Symposium on. IEEE, 2009: 187-194.</li>
<li>[16] Wattenberg M, Viégas F B. The word tree, an interactive visual concordance[J]. IEEE transactions on visualization and computer graphics, 2008, 14(6).</li>
<li>[17] Van Ham F, Wattenberg M, Viégas F B. Mapping text with phrase nets[J]. IEEE transactions on visualization and computer graphics, 2009, 15(6).</li>
<li>[18] Wise J A. The ecological approach to text visualization[J]. Journal of the Association for Information Science and Technology, 1999, 50(13): 1224.</li>
<li>[19] Stasko J, Görg C, Liu Z. Jigsaw: supporting investigative analysis through interactive visualization[J]. Information visualization, 2008, 7(2): 118-132.</li>
<li>[20] Cao N, Sun J, Lin Y R, et al. Facetatlas: Multifaceted visualization for rich text corpora[J]. IEEE transactions on visualization and computer graphics, 2010, 16(6): 1172-1181.</li>
<li>[21] Collins C, Viegas F B, Wattenberg M. Parallel tag clouds to explore and analyze faceted text corpora[C]//Visual Analytics Science and Technology, 2009. VAST 2009. IEEE Symposium on. IEEE, 2009: 91-98.</li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27449788&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphiCon 知乎专栏-文本数据可视化（下）——一图胜千言&lt;/a&gt;&lt;/p
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>文本数据可视化（上）——从 Wordle 谈起</title>
    <link href="http://geekplux.com/2017/04/12/text-data-visualization-wordle.html"/>
    <id>http://geekplux.com/2017/04/12/text-data-visualization-wordle.html</id>
    <published>2017-04-12T02:44:01.000Z</published>
    <updated>2017-04-14T03:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于：<a href="https://zhuanlan.zhihu.com/p/26306683" target="_blank" rel="external">GraphiCon 知乎专栏-文本数据可视化（上）——从 Wordle 谈起</a></p>
</blockquote>
<p>看到题目，你可能一脸懵逼，什么是 wordle？下面这幅图就是：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f0320078efe.png" alt=""></p>
<p>是不是很熟悉？大到宣传海报，小到个人名片，Wordle 如今随处可见。它可以轻松的展示出一段文字的关键词，让我们对这段话的内容一目了然。其实这属于数据可视化中的文本内容可视化，常用于社交网络中的内容分析，<em>还记得前几年微博有有个插件（现在似乎找不到了），用户可以一键生成自己的微博关键词，当时引起了大量转发，因为很多用户的关键词出乎意料，让自己都大吃一惊</em>。本文就从最简单的 Wordle 说起，说说文本内容可视化，以窥数据可视化一隅。</p>
<h2 id="为什么要有-Wordle？"><a href="#为什么要有-Wordle？" class="headerlink" title="为什么要有 Wordle？"></a>为什么要有 Wordle？</h2><p>其实要回答这个问题就要回答为什么要做数据可视化。我们先看下面这段话：</p>
<blockquote>
<p>GraphiCon取GraphicsCon图形控之意（类比lolicon）。<br>我们会把我们觉得有趣的，好玩的，有用的图形学相关的技术，知识，想法，资讯放到GraphiCon这个小空间里。<br>GraphiCon的po主们虽然遍布天涯海角，在从事着不同的事，但都是痴迷计算机图形学的小伙伴们。<br>只要你也对计算机图形学感兴趣，或者喜欢好玩有趣狂拽酷炫的图形项目，那么你也是GraphiCon！</p>
</blockquote>
<p>一眼扫过去，你可能能轻松地注意到 <strong>GraphiCon</strong> 出现了 4 次。而还有个关键词「<strong>图形</strong>」，虽然出现了 5 次，但显然没有 GraphiCon 醒目。平时阅读比较快的同学可能有一目十行的本领，其本质就是关键词提取。瞬间了解一段话的大意，进而判断要不要花时间去读。但这完全取决于你个人提取关键字的能力。如果换一种图形的形式，可能就会非常直观：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e35ca7a99a0.png" alt=""></p>
<p>看这张图明显比看枯燥的文字要直观的多，而且<strong>还意外发现了「计算机图形学」这个词的频率竟然也挺高</strong>。它在原文中出现了两次，这是我们单纯看文字很难发现的。不过，这幅图还不是最好的效果，你可能也发现：除了词频高的词，其他关键词很小，根本看不清；而且整个布局很零散，空白太多，没有一种聚合的感觉。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031f9367fa.png" alt=""></p>
<p>这幅比上面的又稍美观了一点，同时对词的重要性也进行了重新统计，不再是单纯的根据词频。可能你觉得还不够美，那这样：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031f49a275.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/14/58f031f5ad7e5.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/14/58f031f75d220.png" alt=""></p>
<p>哈哈，还有很多好玩的，不过例子中这段话的篇幅太短，关键词太少，所以显得不是很紧凑，很多更酷炫的样式也不适用了。</p>
<p>至此，我们可以总结一下 Wordle 的作用：</p>
<ul>
<li>把枯燥的数据直观地呈现出来，使人更好的洞察数据</li>
<li>更有利于数据分析（比如发现「图形」才是出现最多的词）</li>
</ul>
<p>其实数据可视化就是把复杂的数据转化为直观的图形，方便人们洞悉。而且刚才这个例子还只是最简单的文本数据，如果是非常复杂的数据，普通人根本看不懂的那种，就更需要数据可视化为我们抽丝剥茧，完美呈现。关于可视化的必要性我会慢慢渗透到之后的每一篇文章中，接下来开始介绍 Wordle 的制作过程。</p>
<h2 id="文本信息的提取"><a href="#文本信息的提取" class="headerlink" title="文本信息的提取"></a>文本信息的提取</h2><p>任何的数据可视化都离不开三大步骤[1]：分析、处理、生成，Wordle 亦然[2]。如何从一段文字变成一张优美的图片，我们大概要经历以下步骤：</p>
<ul>
<li>提取关键词（去掉冗余的文字）</li>
<li>计算关键词权重（决定哪些词着重显示）</li>
<li>布局（算出每个词摆放的位置）</li>
</ul>
<p>第一步中，英文的分词相对中文来说简单的多（在创作本文的过程中，我几乎是找遍了中文标签云制作工具，没发现一款分词做的好的），把单词都分开后，去掉一些助词如 the、a、that 等，再把单词的时态语态还原就好了。第二步最常用的就是计算词频了，一个词出现的次数越多它的权重越大（Wordle 就是用了词频）。除此之外，还有用单词在句子中的成分来判断其重要性的、有用各种概率模型的，这涉及到自然语言处理和文本信息挖掘，总之方法多种多样。另外，文本数据挖掘一直也是热门的研究话题，尤其是中文处理这道难以逾越的鸿沟。大家有兴趣可以自行研究。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>把单词任意排列的表现形式，最早的灵感来自于排版印刷：</p>
<p><img src="http://i587.photobucket.com/albums/ss314/zhangdiwaa/my%20blog%20photo/QQ56FE724720140201125127.jpg" alt=""></p>
<p>上图是《数据可视化之美》的配图，分别来自美国国家设计研究中心和古埃及草纸。95 年在动漫作品 EVA 中，词云的表现形式也有所体现[4]。</p>
<p><img src="http://i587.photobucket.com/albums/ss314/zhangdiwaa/my%20blog%20photo/20090621150654-1533987883.jpg" alt=""></p>
<p>这种看似杂乱无章的排布，恰恰与人类的跳跃思维相契合，人脑的思绪随着视觉的跳动也跟着不断联想。</p>
<p>而在计算机上，最早的文字可视化其实是「标签云」。当年博客爆发的时代，几乎每个博客里都有一个这样的插件：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031f6bce01.png" alt=""></p>
<p>它用文字的大小和颜色的深浅来表达了文字在文本中的重要性，比你单纯看一段文字要直观的多。但它的缺点也很多：从美的角度来说，它同一行如果有一个词字体特别大则直接导致行距变大，不仅造成了空间的浪费，还让整体看起来非常不整齐、不协调；从信息展现的角度来说，字体的深浅大小不能更好的体现差异，比如上图中 good 的权重是 50，而 life 的权重是 20，但它俩看起来的差别并不大。</p>
<p>后来出现的 Wordle 针对这些缺点一一作了改进。首先它用字体的粗度来加深权重的展示，因为人的视觉对面积的感知比对饱和度的感知要强，所以加粗字体效果拔群；其次 Wordle 用紧凑的布局给人以美的享受，你甚至可以给定形状来生成不同的 Wordle。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/19/58cd69ce5724c.jpg" alt=""></p>
<p>Wordle 具体采用的算法是贪婪算法，最开始在给定区域内把最重要的单词先摆到某个位置（这个位置你可以指定，一般是中心线），然后用下个单词在它的旁边不停做交叠测试，直到没有重叠。依次迭代，直到每个单词都摆放好。</p>
<h3 id="Wordle-有什么不足之处"><a href="#Wordle-有什么不足之处" class="headerlink" title="Wordle 有什么不足之处"></a>Wordle 有什么不足之处</h3><p>虽然 Wordle 的设计已经很美观，但作为一个有批判性思维的少年，我们还是要对它批判一番：</p>
<ul>
<li>Wordle 美观程度很大程度依赖于它所选的字体。相信你也见过宋体中文的 Wordle。。</li>
<li>相同权重的单词，可能越长的显得权重越大，因为它占得面积更大。</li>
<li>颜色意义不大。不过现在这个好像变成了优势，使它可以与不同图片结合。</li>
</ul>
<h2 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h2><p>Wordle 算是文本内容可视化中最经典的形式，除此之外还有一些更有趣的，比如下图的 DocuBurst [4]。它用环形布局巧妙地展示了文本的层级关系，外圈的单词是内圈单词的下一层。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031fe74aa3.png" alt=""></p>
<p>正所谓“一图胜千言”，文本可视化把枯燥的文字变成有趣的图片帮助人们加深理解，可以说是功不可没。如果有兴趣继续了解可视化相关的内容，敬请期待下一期。</p>
<ul>
<li><a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">[1] 数据可视化基础——可视化流程</a></li>
<li><a href="http://www.wordle.net/" target="_blank" rel="external">[2] Wordle.net</a></li>
<li><a href="https://book.douban.com/subject/6439420/" target="_blank" rel="external">[3] 数据可视化之美</a></li>
<li><a href="http://www.storagelab.org.cn/zhangdi/2014/02/07/wordle/" target="_blank" rel="external">[4] wordle和单词云的起源、原理与制作</a></li>
<li><a href="http://vialab.science.uoit.ca/wp-content/papercite-data/pdf/col2009a.pdf" target="_blank" rel="external">[5] DocuBurst: Visualizing Document Content using Language Structure</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26306683&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphiCon 知乎专栏-文本数据可视化（上）——从 Wordle 谈起&lt;
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我获取信息的渠道</title>
    <link href="http://geekplux.com/2017/01/14/the-ways-to-get-information.html"/>
    <id>http://geekplux.com/2017/01/14/the-ways-to-get-information.html</id>
    <published>2017-01-13T16:10:52.000Z</published>
    <updated>2017-02-22T16:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>互联网迅猛的浪潮抹平了信息的鸿沟，却也让优质的信息变得如沧海一粟。人们常言「信息不对等」，往往在感慨<strong>有价值的信息</strong>总是被人捷足先登。正因这些信息如此重要，催生了一代又一代、各式各样的信息获取工具。</p>
<h2 id="我阅读工具的演化史"><a href="#我阅读工具的演化史" class="headerlink" title="我阅读工具的演化史"></a>我阅读工具的演化史</h2><p>印象中，最早的信息聚合网站，应该是叫「<a href="https://en.wikipedia.org/wiki/Golden_Pages" target="_blank" rel="external">黄页</a>」，已经有 100 多年的历史，马云早期的创业项目就叫「中国黄页」。后来家里的 IE 首页变成了一些门户网站，这时候获取信息主要靠手动点击链接到各大网站。再之后，我接触到了 <strong>Google Reader</strong>，认识了 RSS，从此开启了一扇新的大门。</p>
<p>之前获取信息的方式是自己主动探索，而现在只需要维护好自己的 RSS 订阅列表，就会有感兴趣的信息源源不断地流进来。犹记得当时我的订阅列表很长，每天点开都是几百上千的未读，<strong>快速扫一遍，把感兴趣的随手添加到 pocket（因为 pocket 可以离线阅读），抽碎片时间打开 pocket 阅读，遇到好文章再收藏到 Evernote</strong>，这个阅读流一直沿用了一两年。即使后来 Google Reader 被 Google 遗弃我也坚持用 RSS，只是频率比以前低了不少。</p>
<p>再到后来，不少博客写手开始转战到了微信公众号，很多文章用微信直接阅读，体验也挺好，于是阅读公众号成了我当时新的阅读方式。然而好景不长，很快公众平台就被一堆营销号攻占，一些写手为了圈钱，写作质量也大幅下降。我开始慢慢取关公众号，并且意识到了一个问题：<strong>大多数的文章都是没有价值的，或者说远没有自己想象的有价值</strong>。很多文章都是东拼西凑来的，能引发思考的凤毛麟角。</p>
<p>别人的文章好似二手的知识，我们如果想获取一手的就要追根溯源，看他参考的文献、引用的书籍，与其这样，为什么不直接看书或看论文？想通这点之后，我就把阅读的绝大部分时间放在了看书上，看文章的时间可能一天只有不到半小时。</p>
<h2 id="我现阶段的信息获取方式"><a href="#我现阶段的信息获取方式" class="headerlink" title="我现阶段的信息获取方式"></a>我现阶段的信息获取方式</h2><p>我现在的信息渠道主要分四部分：</p>
<ul>
<li>书籍、论文（不在本文讨论范围内，阅读论文可参考<a href="http://geekplux.com/2016/05/31/how-to-read-a-research-paper.html">《如何阅读一篇学术论文》</a></li>
<li>邮件列表</li>
<li>RSS</li>
<li>经常去逛的一些网站</li>
</ul>
<h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>RSS 列表主要分两部分，一部分是个人博客，另一部分是少数几个信息聚合类网站和一些期刊、杂志。其中重点看个人博客，由于现在大家的博客更新都很慢，所以一般我一周没看也攒不了几篇。期刊杂志我也会留心，因为有一些和我研究方向——数据可视化有关的。</p>
<p>现在我的 RSS 软件主要用 <a href="http://www.inoreader.com/" target="_blank" rel="external">inoreader</a>，基本功能都有，也提供了夜间模式（对于夜猫子来说很重要），感觉还不错。</p>
<h4 id="Mailing-List"><a href="#Mailing-List" class="headerlink" title="Mailing List"></a>Mailing List</h4><p>邮件列表也算是一种很古老的信息获取方式。我主要用它来做两件事：订阅一些 Google Group 来划划水；订阅一些日报和周报。</p>
<p>之所以选择邮件列表看周报，主要是基于以下两个原因：</p>
<ul>
<li>本质上日报或周报已经是别人筛选过一遍的文章，所以质量相对一些信息聚合网站也会高一点</li>
<li>日报或周报降低了阅读的频次</li>
</ul>
<p>日报一天一封，周报一周才一封，保证了你一周只会看这封邮件一次，这大大地节约了浪费在无效信息上的时间。很多网站还提供日报和周报的切换功能，非常方便。</p>
<p>我这里列一些我订阅的，期待大家能在文末评论（或发邮件给我），互通有无。</p>
<ul>
<li><a href="http://weekly.codetengu.com/" target="_blank" rel="external">CodeTengu Weekly 碼天狗週刊</a></li>
<li><a href="http://memect.com/" target="_blank" rel="external">好东西传送门</a> 的机器学习日报、大数据日报、Python、Web 日报</li>
<li><a href="http://www.wildml.com/" target="_blank" rel="external">The Wild Week in AI</a></li>
<li>This week’s hi-res photos from Unsplash</li>
<li><a href="http://javascriptweekly.com/" target="_blank" rel="external">JavaScript Weekly</a></li>
<li><a href="http://frontendfocus.co/" target="_blank" rel="external">FrontEnd Focus</a></li>
<li><a href="https://blog.risingstack.com/" target="_blank" rel="external">RisingStack Engineering</a></li>
<li><a href="http://css-weekly.com/" target="_blank" rel="external">CSS Weekly</a></li>
<li><a href="http://webtoolsweekly.com/" target="_blank" rel="external">Web Tools Weekly</a></li>
<li><a href="http://www.gitxiv.com/" target="_blank" rel="external">GitXiv Top Posts</a></li>
<li><a href="http://rubyweekly.com/" target="_blank" rel="external">Ruby Weekly</a></li>
<li><a href="http://nodeweekly.com/" target="_blank" rel="external">Node Weekly</a></li>
<li><a href="http://dataelixir.com/" target="_blank" rel="external">Data Elixir</a></li>
<li><a href="https://web-design-weekly.com/" target="_blank" rel="external">Web Design Weekly</a></li>
<li>Product Hunt Daily Digest</li>
<li>Quora Digest</li>
<li>Medium Daily Digest</li>
</ul>
<h4 id="经常去逛的"><a href="#经常去逛的" class="headerlink" title="经常去逛的"></a>经常去逛的</h4><p>人不能两耳不闻窗外事，总得适当的划水。我经常去逛的网站有</p>
<ul>
<li><a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a></li>
<li><a href="https://www.reddit.com/" target="_blank" rel="external">reddit</a> - <a href="https://www.reddit.com/r/programming" target="_blank" rel="external">programming</a> 质量不错</li>
<li><a href="https://github.com/explore" target="_blank" rel="external">GitHub Explore</a> - 当然我邮件里也订阅了这个</li>
<li><a href="https://www.v2ex.com/" target="_blank" rel="external">v2ex</a> - v 站虽然划水时间占 99%，但小道消息还挺多的</li>
<li><a href="http://www.bilibili.com/" target="_blank" rel="external">bilibili</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>任何事都是先做加法，再做减法的过程。我的 RSS 列表和邮件列表都曾经短期内迅速变长，后来又被我精心筛选到寥寥无几，不过我现在还是觉得有点多。</p>
<p>我用的工具可能都比较复古，但是经久不衰的东西才真正不会被淘汰。尤其是邮件，这个几乎是网络一出现就有的东西，现在、未来都会依旧重要。</p>
<p>最后还有个小技巧：文章是否值得读，不取决于题目是否夺人眼球，可能取决于你多个信息渠道中它重复出现的次数。</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>既然本文是信息获取的渠道，那就不应该局限于阅读方面。除了阅读以为，Podcast 也是我特别喜爱的信息获取方式。我目前一共订阅了 54 个 Podcast，其中大部分是和科技相关，IPN 系列之前搞的很专业，但是现在不太行了。《锵锵三人行》是我逢人推荐的，从小听到大。听 Podcast 可以主观上缩短你的通勤时间，虽然没有阅读那么效率，但作为陶冶情操、增广见闻的手段还是可以的。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互联网迅猛的浪潮抹平了信息的鸿沟，却也让优质的信息变得如沧海一粟。人们常言「信息不对等」，往往在感慨&lt;strong&gt;有价值的信息&lt;/strong&gt;总是被人捷足先登。正因这些信息如此重要，催生了一代又一代、各式各样的信息获取工具。&lt;/p&gt;
&lt;h2 id=&quot;我阅读工具的演化史&quot;
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="学习" scheme="http://geekplux.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Learning" scheme="http://geekplux.com/tags/Learning/"/>
    
      <category term="Read" scheme="http://geekplux.com/tags/Read/"/>
    
      <category term="阅读" scheme="http://geekplux.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化基础——视觉编码</title>
    <link href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html"/>
    <id>http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html</id>
    <published>2017-01-03T12:02:52.000Z</published>
    <updated>2017-08-18T03:44:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第三篇，主要介绍<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>，另两篇则主讲<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">可视化流程</a>和<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>，建议从可视化流程看起。<br>原文地址：<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html</a></p>
</blockquote>
<p>终于来到了最后一篇，前两篇的铺垫可能有点长，但是不种苗浇水怎能开枝散叶。可视化编码是可视化中的<strong>核心内容</strong>，本文会对其进行详细的讲解，尤其是<strong>视觉编码</strong>与<strong>视觉通道</strong>两个概念，如果其中遇到晦涩之处，不要心急，可囫囵吞枣直接往下看。</p>
<h2 id="什么是视觉编码（visual-encoding）"><a href="#什么是视觉编码（visual-encoding）" class="headerlink" title="什么是视觉编码（visual encoding）"></a>什么是视觉编码（visual encoding）</h2><p>很多人可能看到题目的时候就有这个疑问，到底什么是视觉编码。其实视觉编码很简单，用一句话就能概括：</p>
<blockquote>
<p>视觉编码描述的是将数据映射到最终可视化结果上的过程。</p>
</blockquote>
<p>这里的可视化结果可能是图片，也可能是一张网页等等。</p>
<p>编码二字，如果说<strong>编</strong>是指设计、映射的过程，那么码呢？<strong>码</strong>其实指的是一些图形符号。</p>
<h2 id="图形能告诉我们什么"><a href="#图形能告诉我们什么" class="headerlink" title="图形能告诉我们什么"></a>图形能告诉我们什么</h2><p>在介绍各类图形符号之前，我们先谈谈：图形能告诉我们什么。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/pic.png" alt=""></p>
<p>仔细观察上方这个简单的图片，你能得得到什么信息？</p>
<ol>
<li>A B C 是不同的</li>
<li>B 在 A 和 C 的中间</li>
<li>BC 的长度是 AB 的大概两倍</li>
</ol>
<p>得益于我们视觉系统的强大，这些信息不假思索就能得出。如果把上图想象成一个二维坐标系，则我们可能得出更多的结论。</p>
<blockquote>
<p>“Resemblance, order and proportion are the three signfields in graphics.” - Bertin [1]</p>
</blockquote>
<p>图形符号和信息间的映射关系使我们能迅速获取信息。所以我们可以把图片看成一组图形符号的组合，这些图形符号中<strong>携带</strong>了一些信息，我们称作它<strong>编码</strong>了一些信息。而当人们从这些符号中<strong>读取</strong>信息时，我们称作我们<strong>解码</strong>了一些信息。</p>
<p>我们人类解码信息靠的是我们的眼睛、我们的视觉系统。如果说图形符号是编码信息的工具或通道、那么我们的视觉就是解码信息的通道。因此，我们通常把这种<strong>图形符号&lt;——&gt;信息&lt;——&gt;视觉系统</strong>的对应称作<strong>视觉通道</strong>。</p>
<p>至此算是把<strong>视觉通道</strong>、<strong>视觉编码</strong>这两个概念讲清楚了。如果一个人说他想用四个通道来编码四个维度的数据，即可以翻译成他想用四种图形符号来对应这份数据表的四个列的信息。</p>
<p>这里举个例子（例子来自于 [2]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a>）：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/example.png" alt="例子来自于陈为 沈则潜 陶煜波《数据可视化》"></p>
<ul>
<li>上图中图 A 表示了三个不同班级的数学平均分，用柱状图表示，柱状图的<strong>高度</strong>作为一个视觉通道，编码了数学平均分的<em>值</em>；柱状，这个<strong>形状</strong>作为一个视觉通道编码了数学平均分这一<em>属性</em>。</li>
<li>图 B 中，我们想在 A 的基础上多展示语文平均分这一项数据（即增加了一个数据维度），则选用点这个<strong>形状</strong>通道编码这两个<em>属性</em>；点的<strong>横坐标</strong>编码语文平均分的<em>值</em>；点的<strong>纵坐标</strong>编码数学平均分的<em>值</em>。</li>
<li>这时候发现图 B 中我们把班级这个数据维度给丢掉了，于是我们可以用<strong>颜色</strong>这一视觉通道来编码班级这个<strong>属性</strong>信息，如图 C。</li>
<li>如果我们还想展示班级<em>人数</em>这一信息，则可以用<strong>尺寸</strong>这一视觉通道来编码，如图 D。</li>
</ul>
<h2 id="视觉编码中常用的视觉通道"><a href="#视觉编码中常用的视觉通道" class="headerlink" title="视觉编码中常用的视觉通道"></a>视觉编码中常用的视觉通道</h2><p>1967 年，Jacques Bertin 初版的《Semiology of Graphics》一书提出了图形符号与信息的对应关系（就是本文上一节的内容），奠定了可视化编码的理论基础。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/signal.png" alt="Bertin J. Semiology of graphics: diagrams[C]// Conference on Computer Networks. 1983."></p>
<p>如上图所示，书中把图形符号分为两种：</p>
<ul>
<li><strong>位置变量</strong>：一般指二维坐标</li>
<li><strong>视网膜变量</strong>：<strong>尺寸</strong>、<strong>数值</strong>、<strong>纹理</strong>、<strong>颜色</strong>、<strong>方向</strong>和<strong>形状</strong></li>
</ul>
<p>以上基本的图形符号共有 7 种。将其映射到点、线、面之后，就相当于有 21 种编码可用的视觉通道。后来人们还又补充了几种其他的视觉通道：<strong>长度</strong>、<strong>面积</strong>、<strong>体积</strong>、<strong>透明度</strong>、<strong>模糊/聚焦</strong>、<strong>动画</strong>等，所以可用的视觉通道其实太多了。</p>
<p>而一般一份可视化作品可用到的视觉通道要尽可能得少，因为太多了反而会造成我们视觉系统的混乱，使我们获取信息更难。于是这就涉及到了视觉通道的设计原则。</p>
<h2 id="视觉编码设计原则"><a href="#视觉编码设计原则" class="headerlink" title="视觉编码设计原则"></a>视觉编码设计原则</h2><p>这一节其实可以单独再分一篇文章写，因为可视化编码设计实在是复杂：假设我们有 k 个视觉通道，有 n 个数据维度，则一共有 <code>(n+1)^k</code> 种编码方案……从中选出一种最佳方案难度可见一斑。</p>
<p>不过既然本文是讲解视觉编码相关，所以这个章节是逃不掉的，在此提纲挈领讲一下。如果想深入了解，可以阅读参考文献中提到的书籍。</p>
<h3 id="视觉通道的三个性质"><a href="#视觉通道的三个性质" class="headerlink" title="视觉通道的三个性质"></a>视觉通道的三个性质</h3><p>上一篇<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>讲解了可视化中数据分为三类：<strong>类别型</strong>、<strong>有序型</strong>、<strong>数值型</strong>。</p>
<ol>
<li><strong>定性性质</strong>（或叫分类性质）。适用于类别型数据。比如形状或颜色，这两个视觉通道，非常容易被人眼识别。从一堆正方形中识别出一个三角形，或看万绿丛中一点红，都是我们眼睛拿手好戏。</li>
<li><strong>定量性质或定序性质</strong>。适用于有序型和数值型数据。比如长度、大小特别适合于编码数值/量的大小。</li>
<li><strong>分组性质</strong>。具有相同视觉通道的数据，人眼也能很快识别出来，将其归为一组。</li>
</ol>
<p>总结一下视觉通道与数据类型的对应关系，如下图所示：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/level.png" alt="视觉通道与数据类型的对应"></p>
<h3 id="视觉编码设计的两大原则"><a href="#视觉编码设计的两大原则" class="headerlink" title="视觉编码设计的两大原则"></a>视觉编码设计的两大原则</h3><p>Mackinlay[4] 和 Tversky[5] 分别提出了两套可视化设计的原则，Mackinlay 强调表达性和有效性，Tversky 强调一致性和理解性。两者可以糅合起来：</p>
<ol>
<li><strong>表达性、一致性</strong>：可视化的结果应该充分表达了数据想要表达的信息，且没有多余。</li>
<li><strong>有效性、理解性</strong>：可视化之后比前一种数据表达方案更加有效，更加容易让人理解。</li>
</ol>
<p>下面这张图总结了视觉编码面对不同数据类型的优先级：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/level2.png" alt="视觉编码面对不同数据类型的优先级"></p>
<p>如果要具体展开每项视觉通道来说，未免有点太繁琐，而且设计可视化编码除了视觉通道还需要考虑：</p>
<ul>
<li>色彩搭配</li>
<li>交互</li>
<li>美学因素</li>
<li>信息的密度</li>
<li>直观映射、隐喻</li>
</ul>
<p>以上每一项都很重要，之后有机会再写吧。这个可视化基础系列总算是完结了，文字虽然不多，但是搜索资料、读论文、总结等还是挺累的，希望你能有所收获。欢迎各位在我博客文末留言讨论（如果看不到评论框可能是因为你没有科学上网）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1]Bertin J. Semiology of graphics: diagrams[C]// Conference on Computer Networks. 1983.</li>
<li>[2]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[3]<a href="http://courses.cs.washington.edu/courses/cse512/16sp/" target="_blank" rel="external">CSE512 Data Visualization (Spring 2016)</a></li>
<li>[4]Mackinlay, Jock. Automating the design of graphical presentations of relational information[J]. Acm Transactions on Graphics, 1986, 5(2):110-141.</li>
<li>[5]Tversky B, Morrison J B, Betrancourt M. Animation: Can it facilitate?[J]. International Journal of Human-Computer Studies, 2002, 57(4):247-262.</li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第三篇，主要介绍&lt;a href=&quot;http://geekplux.com/2017/01/03/basics-of-data-visualization-visu
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化基础——数据模型</title>
    <link href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html"/>
    <id>http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html</id>
    <published>2017-01-02T04:01:48.000Z</published>
    <updated>2017-01-10T05:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第二篇，主要介绍<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>，另两篇则主讲<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">可视化流程</a>和<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>，建议从可视化流程看起。<br>原文地址：<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html</a></p>
</blockquote>
<p>数据说白了就是一组可定性或可量化的值。随着计算机存储能力的大幅提高，人们对于数据的关注与日俱增，「大数据」一词近几年来也被人们频频提及。而数据可视化的主要任务是将数据转换为易于感知的图形。因此，为了更准确更形象的表达数据，我们需要了解一些数据相关的概念。</p>
<h2 id="数据模型与概念模型"><a href="#数据模型与概念模型" class="headerlink" title="数据模型与概念模型"></a>数据模型与概念模型</h2><p>为什么数据能代表我们的世界？要回答这个问题，我们得先了解数据和概念两个模型。</p>
<p><strong>数据模型</strong>是一组数字或符号的组合，它包含数据的定义、类型等，可以进行各类数学操作等。<strong>概念模型</strong>描述的是事物的语义或状态行为等。</p>
<p><strong>现实</strong> =&gt; <strong>概念</strong> =&gt; <strong>数据</strong></p>
<p>现实世界可以用概念模型来描述，而概念模型又可以用数据模型来描述。经过两层抽象，数据便可以描述我们的现实生活中的方方面面。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>一个东西具体归为哪一类，取决于我们用什么标准划分，数据亦然。</p>
<p>从数据在计算机中的存储可分为浮点数、整数、字符等；从关系模型的角度分，数据又可以分为实体和关系两类；从数据的结构来分，可以分为一维、二维、三维、多维、时间序列、空间序列、树型、图型等等[3]；还有很多的分类方法，我们暂时先不讨论，把关注点聚焦到和数据可视化有关的分类方法上。</p>
<p>按照测量标度来分，数据一般被分为四类：<strong>类别型</strong>、<strong>有序型</strong>、<strong>区间型</strong>、<strong>比值型</strong>。</p>
<ul>
<li><strong>类别型</strong>数据用于区分事物。例如，人可以分为男女，水果能分为苹果香蕉等。</li>
<li><strong>有序型</strong>用来表示对象间的顺序关系。例如，我们的身高可以从矮到高，学生的成绩可以从低到高排列等。</li>
<li><strong>区间型</strong>用于对象间的定量比较。例如，身高 160cm 与身高 170cm 相差 10cm，而 170cm 与 180cm 也相差 10cm，它们俩的差值是相等的。由此可见，区间型数据基于任意的起始点，所以它只能衡量对象间的相对差别。</li>
<li><strong>比值型</strong>用于比较数值间的比例关系。例如，体重 80kg 是体重 40kg 的两倍。</li>
</ul>
<p>不同的数据类型适用于不同的操作[1]：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">集合操作</th>
<th style="text-align:left">统计操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类别型</td>
<td style="text-align:left">=、≠</td>
<td style="text-align:left">互换元素位置</td>
<td style="text-align:left">类别、模式、列联相关</td>
</tr>
<tr>
<td style="text-align:left">有序型</td>
<td style="text-align:left">=、≠、&gt;、&lt;</td>
<td style="text-align:left">计算元素单调递增（减）</td>
<td style="text-align:left">中值、百分位数</td>
</tr>
<tr>
<td style="text-align:left">区间型</td>
<td style="text-align:left">=、≠、&gt;、&lt;、+、-</td>
<td style="text-align:left">元素间线性加（减）</td>
<td style="text-align:left">平均值、标准方差、等级相关、积差相关</td>
</tr>
<tr>
<td style="text-align:left">比值型</td>
<td style="text-align:left">=、≠、&gt;、&lt;、+、-、×、÷</td>
<td style="text-align:left">元素间相似度</td>
<td style="text-align:left">变异系数</td>
</tr>
</tbody>
</table>
<p>不过，在数据可视化中，我们通常不特别区分区间型和比值型，将其统称为<strong>数值型</strong>。进而可将数据类型进一步精简为三种：<strong>类别型</strong>、<strong>有序型</strong>、<strong>数值型</strong>。具体为什么要分为这三类，我相信你看完下一篇<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>之后会完全明白。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>说了那么多，都比较抽象，不如直接来看个例子。下面是一个简单的数据表，每一行通常称作一条<strong>记录</strong>，每一列称作一个<strong>字段</strong>，共有几个字段，则通常就说这份数据有几个<strong>维度</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">款式</th>
<th style="text-align:left">尺码</th>
<th style="text-align:left">销量</th>
<th style="text-align:left">年增长</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">男款</td>
<td style="text-align:left">上衣</td>
<td style="text-align:left">L</td>
<td style="text-align:left">50</td>
<td style="text-align:left">10%</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">女款</td>
<td style="text-align:left">上衣</td>
<td style="text-align:left">S</td>
<td style="text-align:left">35</td>
<td style="text-align:left">5%</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">女款</td>
<td style="text-align:left">裤子</td>
<td style="text-align:left">M</td>
<td style="text-align:left">40</td>
<td style="text-align:left">20%</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">男款</td>
<td style="text-align:left">上衣</td>
<td style="text-align:left">XL</td>
<td style="text-align:left">30</td>
<td style="text-align:left">15%</td>
</tr>
</tbody>
</table>
<p>对照我们上文的概念，不难判断出上表中：</p>
<ul>
<li>类型、款式为类别型数据；</li>
<li>id、尺码为有序型数据；</li>
<li>销量和年增长为数值型数据。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，其实本文的任务就已经完成了。通篇传递的最重要的知识就是数据可视化中的三大数据类型，消化了这点，下一篇<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>就能更好的理解。欢迎各位在我博客文末留言讨论（如果看不到评论框可能是因为你没有科学上网）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[2]<a href="http://www.cad.zju.edu.cn/home/vagblog/?page_id=1302" target="_blank" rel="external">浙江大学-陈为、巫英才数据可视化课程</a></li>
<li>[3]Shneiderman B. The eyes have it: a task by data type taxonomy for information visualizations[C]// Visual Languages, 1996. Proceedings. IEEE Symposium on. IEEE Xplore, 1996:336-343.</li>
<li>[4]<a href="http://courses.cs.washington.edu/courses/cse512/16sp/" target="_blank" rel="external">CSE512 Data Visualization (Spring 2016)</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第二篇，主要介绍&lt;a href=&quot;http://geekplux.com/2017/01/02/basics-of-data-visualization-data
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化基础——可视化流程</title>
    <link href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html"/>
    <id>http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html</id>
    <published>2017-01-01T09:35:36.000Z</published>
    <updated>2017-01-13T14:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第一篇，主要介绍<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">可视化流程</a>，另两篇则主讲<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>和<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>。<br>原文地址：<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html</a></p>
</blockquote>
<p>很多人认为数据可视化非常简单，无非是输入几组数据，生成简单的条形图、直线图等等。然而，这未免有点管中窥豹。其实数据可视化大致可分为<strong>信息可视化</strong>、<strong>科学可视化</strong>和<strong>可视化分析</strong>三大类，刚才提到的简单图表只是信息可视化中最常见的几种。一旦数据量增大，可视化目标改变，可视化系统的复杂度可能就会超出我们的想象。本文中涉及到的可视化流程模型适用于信息可视化和科学可视化。可视化分析的流程模型略有不同，本文暂时不进行讨论。</p>
<h2 id="通用的可视化流程"><a href="#通用的可视化流程" class="headerlink" title="通用的可视化流程"></a>通用的可视化流程</h2><p>做任何事都有一个流程，可视化也不例外。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/Screen%20Shot%202017-01-01%20at%2018.04.55.png" alt="数据可视化流程总览"></p>
<p>一图以蔽之。可视化整体可分为三步：<strong>分析</strong>-<strong>处理</strong>-<strong>生成</strong>。</p>
<h3 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h3><p>进行一个可视化任务时，我们首当其冲的当然是要分析，分析又分为三部分：任务、数据、领域。</p>
<p>首先我们要分析我们这次可视化的出发点和目标是什么。我们遇到了什么问题、要展示什么信息、最后想得出什么结论、验证什么假说等等。数据承载的信息多种多样，不同的展示方式会使侧重点有天壤之别。只有想清楚以上问题，才能确定我们要过滤什么数据、用什么算法处理数据、用什么视觉通道编码等等。</p>
<p>其次我们要分析我们的数据，这是至关重要的一步。因为每次可视化任务拿到的数据都是不同的，数据类型、数据结构均有变化，数据的维度也可能成倍增加。抽象的数据类型如何对应现实中的概念，不同的数据类型如何进行视觉编码，这些我们在下一篇<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>中进行介绍。</p>
<p>最后我们针对不同的领域，也要进行相应的分析。毕竟术业有专攻，可视化的侧重点要跟着领域做出相应的变化。</p>
<h3 id="二、处理"><a href="#二、处理" class="headerlink" title="二、处理"></a>二、处理</h3><p>处理可以分为两部分：<strong>对数据的处理</strong>和<strong>对视觉编码的处理</strong>。</p>
<h4 id="1-数据处理"><a href="#1-数据处理" class="headerlink" title="1.数据处理"></a>1.数据处理</h4><p>在可视化之前我们要对数据进行数据清洗、数据规范、数据分析。</p>
<p>数据清洗和规范是必不可少的步骤。首先把脏数据、敏感数据过滤掉，其次再剔除和我们目标无关的冗余数据，最后调整数据结构到我们系统能接受的方式。</p>
<p>数据分析中最简单的方法当然是一些基本的统计方法，如求和、中值、方差、期望等等；复杂的方法有数据挖掘种的各种算法，这是又一个领域了，在此不赘述。</p>
<p>最后的可视化结果中我们肯定不可能把所有的数据统统展示出来，于是又涉及到包括标准化（归一化）、采样、离散化、降维、聚类等数据处理的方法，这些概念之后可以单独写篇文章来介绍。</p>
<h4 id="2-设计视觉编码"><a href="#2-设计视觉编码" class="headerlink" title="2.设计视觉编码"></a>2.设计视觉编码</h4><p>视觉编码的设计是指如何使用位置、尺寸、灰度值、纹理、色彩、方向、形状等视觉通道，以映射我们要展示的每个数据维度。这里看不懂没关系，第三篇<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>中会详细介绍。</p>
<h3 id="三、生成"><a href="#三、生成" class="headerlink" title="三、生成"></a>三、生成</h3><p>这个阶段基本上就是把之前的分析和设计付诸实践，在制作或写代码过程中，再不断调整需求、不断地迭代（有可能要重复前两步），最后产出我们想要的结果。</p>
<h2 id="其它可视化流程"><a href="#其它可视化流程" class="headerlink" title="其它可视化流程"></a>其它可视化流程</h2><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p>1990 年 Robert B. Haber 和 David A. McNabb 提出的数据可视化流程已经非常先进：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/conceptual-model.png" alt="Haber, R. B. and McNabb, D. A. Visualization idioms: A conceptual model for scientific visualization systems, 1990."></p>
<p>这个处理模型非常先进，整个流程是线性的。它把数据分成五大阶段，分别要经历四个流程，每个过程的输入是上一个过程的输出。从图上看非常直观，很好理解。</p>
<h3 id="嵌套模型"><a href="#嵌套模型" class="headerlink" title="嵌套模型"></a>嵌套模型</h3><p>另一种模型是嵌套模型：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/nested-model.png" alt="Munzner T. A Nested Process Model for Visualization Design and Validation\[J\]. IEEE Transactions on Visualization &amp; Computer Graphics, 2009, 15(6):921-8."></p>
<p>嵌套模型的上半部分基本上就是我们之前说的分析、处理两步，下半部分是对可视化结果的各类验证。本质上就是一个验证加迭代的过程。我们知道很多事都不是一蹴而就的，需要不断迭代，所以有人提出了循环模型。</p>
<h3 id="循环模型"><a href="#循环模型" class="headerlink" title="循环模型"></a>循环模型</h3><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/cyclical-model-1.png" alt="Stolte C, Hanrahan P. Polaris: a system for query, analysis and visualization of multi-dimensional relational databases[C]// IEEE Symposium on Information Visualization. 2000:5-14."></p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/cyclical-model-2.png" alt="Wijk J J V. The Value of Visualization[C]// Visualization, 2005. VIS 05. IEEE. 2005:11-11."></p>
<p>循环模型的两张图其实都是把线性模型首尾连起来，从图上看一目了然。</p>
<h3 id="目前应用最广的模型"><a href="#目前应用最广的模型" class="headerlink" title="目前应用最广的模型"></a>目前应用最广的模型</h3><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/best-process-model.png" alt="Card S K, Mackinlay J D, Shneiderman B. Readings in information visualization: using vision to think[M]// Readings in information visualization :. Morgan Kaufmann Publishers, 1999:647-650."></p>
<p>对比之前的线性模型，其实也很类似，不过其在最后加入了用户交互的部分，且让每个步骤都变成了循环的。这是目前应用最广的可视化流程模型，后继几乎所有著名的信息可视化系统和工具都支持、兼容这个模型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纵观以上提到的各类模型，都非常类似，本质上还是离不开<strong>分析</strong>-<strong>处理</strong>-<strong>生成</strong>三步，所以掌握第一张图就可以了，以不变应万变。文中多次提到视觉编码、数据处理等概念，我们在接下来的两篇<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>和<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>介绍。欢迎各位在我博客文末留言讨论（如果看不到评论框可能是因为你没有科学上网）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[2]<a href="http://www.cad.zju.edu.cn/home/vagblog/?page_id=1302" target="_blank" rel="external">浙江大学-陈为、巫英才数据可视化课程</a></li>
<li>[3]Haber, R. B. and McNabb, D. A. Visualization idioms: A conceptual model for scientific visualization systems, 1990.</li>
<li>[4]Munzner T. A Nested Process Model for Visualization Design and Validation[J]. IEEE Transactions on Visualization &amp; Computer Graphics, 2009, 15(6):921-8.</li>
<li>[5]Stolte C, Hanrahan P. Polaris: a system for query, analysis and visualization of multi-dimensional relational databases[C]// IEEE Symposium on Information Visualization. 2000:5-14.</li>
<li>[6]Wijk J J V. The Value of Visualization[C]// Visualization, 2005. VIS 05. IEEE. 2005:11-11.</li>
<li>[7]Card S K, Mackinlay J D, Shneiderman B. Readings in information visualization: using vision to think[M]// Readings in information visualization :. Morgan Kaufmann Publishers, 1999:647-650.</li>
<li>[8]<a href="http://courses.cs.washington.edu/courses/cse512/16sp/" target="_blank" rel="external">CSE512 Data Visualization (Spring 2016)</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第一篇，主要介绍&lt;a href=&quot;http://geekplux.com/2017/01/01/basics-of-data-visualization-the-
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>为什么要用 Emacs</title>
    <link href="http://geekplux.com/2016/12/03/why-use-emacs.html"/>
    <id>http://geekplux.com/2016/12/03/why-use-emacs.html</id>
    <published>2016-12-03T07:22:17.000Z</published>
    <updated>2016-12-04T07:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文仅从作者个人感受上谈一下自己使用 Emacs 的理由和感受，通篇无干货。</p>
</blockquote>
<p>Emacs 和 Vim 这两大编辑器，一直让前赴后继的工具党难以取舍。到底学哪一个？哪一个学了之后能如虎添翼？最初的我也是纠结了许久，仿佛本科时纠结到底该主学 C++ 还是主学 Java 一样。而事实上正如前辈们说的：<em>不要纠结学哪个，反正迟早都要学</em>。</p>
<h2 id="使用-Emacs-的若干好处"><a href="#使用-Emacs-的若干好处" class="headerlink" title="使用 Emacs 的若干好处"></a>使用 Emacs 的若干好处</h2><p>从我个人的角度讲，我认为学习和使用 Emacs 有以下几个好处：</p>
<ul>
<li><strong>掌握了一个几乎能完成任何事，又可以随心所欲修改的编辑器</strong></li>
<li><strong>入了 lisp 的门</strong></li>
<li><strong>混进了一个牛人众多的社区</strong></li>
</ul>
<p>搜索过 Emacs 的人对前两点应该都有所耳闻，但百闻不如一见，真正使用之后才知道 Emacs 多强大。就我个人来说，除了将 Emacs 作为多种编程语言的编辑器，还用来管理自己的<a href="http://geekplux.com/wiki">学习笔记</a>、To-Do List。社区里很多道友还用它来记账、管理文献、写论文等等（<em><a href="https://emacs-china.org/t/emacs/61" target="_blank" rel="external">大家都用 Emacs 做什么？</a></em>）。如果你对 Emacs 没兴趣，那么至少应该了解一下 <a href="http://orgmode.org/" target="_blank" rel="external">Org-Mode</a>，由于 Org-Mode 的强大，有人甚至用它来<a href="http://doc.norang.ca/org-mode.html" target="_blank" rel="external">管理自己的一生</a>（<em>类似<a href="https://book.douban.com/subject/1115353/" target="_blank" rel="external">《奇特的一生》</a>中提到的方法</em>）。Org 其实就像 MarkDown 一样，是一种标记语言，想想能用纯文本去管理自己的一生，是不是还有点小激动。</p>
<p><img src="https://emacs-china.org/uploads/default/original/1X/606931976e4756474b5654f33e74171250d63c3e.jpeg" alt="用 Emacs 查看天气"></p>
<p>由于 Emacs 的配置都是用 elisp 这个 lisp 的方言去写的，所以学习 lisp 终于有了用武之地。不过 lisp 属于「规则简单，威力无穷」，学习它其实不会花太多时间，但要理解它的精髓和使用好它真的很难。</p>
<p>除了以上两点，还有一个最关键的好处是：认识了很多牛人。不得不说，<strong>Emacs 的高门槛和小众，决定了其使用者的质量</strong>。很多 Emacs 道友来自非计算机行业，有的学化学，有的做木工，非常有趣。而且大家都特别有钻研精神，这可能也是所有 Emacs 玩家的共同点。</p>
<h2 id="我是如何中了-Emacs-的毒"><a href="#我是如何中了-Emacs-的毒" class="headerlink" title="我是如何中了 Emacs 的毒"></a>我是如何中了 Emacs 的毒</h2><p>其实最早听说 Emacs 是在本科的时候。下载下来拨弄一番后发现难点在于记忆快捷键，实现一个自己想要的操作可能需要按一系列按键，有点像<strong>记忆菜单栏快捷键</strong>的感觉（<em>现在不这么认为了，现在完成一个操作我可能都是直接调用 Emacs 的函数，因为 Emacs 中任何一个操作其实都是一个函数</em>）。每一个快捷键组合打开一个「子菜单」，最终要实现的操作有可能在三级子菜单中，所以感觉相当繁琐。后来每每雄心壮志重新开始学习，都会被记忆快捷键这个拦路虎挡住。</p>
<p>当然，学习 Vim 也如此。在不知道多少次折腾后，我还是先掌握了 Vim，学习历程和方式参见这篇 <a href="http://geekplux.com/2015/06/06/vim-those-fit-yourself-are-the-best.html">Vim - 适合自己的，才是最好的</a>。Vim 的哲学和 Emacs 不同，它把输入分成 <strong>纯输入</strong> 和 <strong>操作</strong> 两种模式（个人理解）。纯输入就是单纯的输入字符，需要换行、移动光标、复制粘贴时则需要「操作」。我觉得这种很符合大脑的思考方式，输入时单纯想着内容就好，需要「整理」内容时再操作。</p>
<p>但是我想用 Emacs 之心不死，当时主要因为 Org-Mode 对我的吸引力很大。在听说 Emacs 有 evil 之后，果断转了过去，瞬间觉得学习曲线变得顺滑了。再之后发现了颜值颇高的 Spacemacs，于是更加爱不释手。Spacemacs 的文档非常详尽，还提供了如何从 Vim 迁移的方案，对我这种菜鸟真的是非常友好。</p>
<p>从此，便算是入了坑，之后的填坑之路也是漫长，比如如何配置，如何使用 Org-Mode，如何寻找适合自己的最佳实践，每部分都能长篇大论一番。</p>
<p>如果你有兴趣，还可以去 <a href="https://emacs-china.org/t/emacs-joy/80" target="_blank" rel="external">来聊聊大家是怎么入 Emacs 这个大坑的吧</a> 看看其他人入坑的经历。</p>
<h3 id="关于-Emacs-的学习曲线"><a href="#关于-Emacs-的学习曲线" class="headerlink" title="关于 Emacs 的学习曲线"></a>关于 Emacs 的学习曲线</h3><p>有的人推崇从最原生的 Emacs 学起，自己一步步配置，有的人推崇直接用社区大牛写好的配置，我显然是后者。<a href="https://github.com/syl20bnr/spacemacs/" target="_blank" rel="external">Spacemacs</a> 就是一款对新手和 Vim 党非常友好的配置，而且文档写的<strong>特别详细</strong>，只要你<strong>耐心</strong>读，绝对是可以从容掌握它的，实在遇到困难可以在社区<strong>正确</strong>提问，只要你问题不是很让人反感，都会有很多大牛热心帮你（<em>这里我不禁要说一句，如果你是伸手党，那么 Emacs 是真的不适合你</em>）。</p>
<h3 id="关于使用-Emacs-太折腾"><a href="#关于使用-Emacs-太折腾" class="headerlink" title="关于使用 Emacs 太折腾"></a>关于使用 Emacs 太折腾</h3><p>刚开始确实花很多时间在折腾上，但是现在不会了。因为我发现，对工具「折腾」的越多，定制越深，就会越<strong>依赖</strong>这个工具。一旦需要在别的电脑上编程，双手都感觉不是自己的了。同时，折腾后的「效率提升」其实我们自己都知道效果并不明显，有的需求完全是<strong>伪需求</strong>。强迫自己适应一个新的操作方式，虽然对自己是一个训练，但不需要以提升效率为借口。所以我现在基本上除了一些影响使用上的改动外，基本上维持默认配置，强迫自己适应默认配置，适应才是对效率的最大提升。</p>
<p>不过，一旦开始折腾，很容易<strong>停不下来</strong>，你懂的。。。一下午甚至一天的时间一瞬间就没了。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://emacs-china.org/t/emacs/111" target="_blank" rel="external">编辑器辣么多，为什么你还在使用 Emacs?</a></li>
<li><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org" target="_blank" rel="external">一年成为Emacs高手(像神一样使用编辑器)</a></li>
<li><a href="https://github.com/emacs-china/Spacemacs-rocks" target="_blank" rel="external">Spacemacs Rocks 21 天掌握 Emacs</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文仅从作者个人感受上谈一下自己使用 Emacs 的理由和感受，通篇无干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Emacs 和 Vim 这两大编辑器，一直让前赴后继的工具党难以取舍。到底学哪一个？哪一个学了之后能如虎添翼？最初的我也是纠结了
    
    </summary>
    
      <category term="Tool" scheme="http://geekplux.com/categories/Tool/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Vim" scheme="http://geekplux.com/tags/Vim/"/>
    
      <category term="Emacs" scheme="http://geekplux.com/tags/Emacs/"/>
    
      <category term="IDE" scheme="http://geekplux.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Vega-Lite: A Grammar of Interactive Graphics</title>
    <link href="http://geekplux.com/2016/11/02/vega-lite-a-grammar-of-interactive-graphics.html"/>
    <id>http://geekplux.com/2016/11/02/vega-lite-a-grammar-of-interactive-graphics.html</id>
    <published>2016-11-02T08:16:16.000Z</published>
    <updated>2016-12-03T10:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在 InfoVis 2016 上，<a href="http://idl.cs.washington.edu/" target="_blank" rel="external">UW 交互数据实验室</a> 提出了一种新的交互数据可视化语法——Vega-Lite，获得了今年的 best paper，本文将根据其论文从多个角度介绍 Vega-Lite。<a href="http://idl.cs.washington.edu/papers/vega-lite/" target="_blank" rel="external">论文地址</a></p>
</blockquote>
<h2 id="什么是-Vega-Lite"><a href="#什么是-Vega-Lite" class="headerlink" title="什么是 Vega-Lite"></a>什么是 Vega-Lite</h2><p>简而言之，<a href="https://vega.github.io/vega-lite/" target="_blank" rel="external">Vega-Lite</a> 是一种数据可视化的高级语法，能够快速定义一些基本的交互式数据可视化。</p>
<p>如果你听说过 <a href="https://vega.github.io/vega/" target="_blank" rel="external">Vega</a>，那么光看 Vega-Lite 的名字就不难想到它们的关系。Vega-Lite 就是编译成 Vega 的更高级图形语法。</p>
<p>如下图所示，只要右边寥寥数行代码，就能定义一个散点图：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/sctterplot1.png" alt=""></p>
<h2 id="为什么要提出-Vega-Lite"><a href="#为什么要提出-Vega-Lite" class="headerlink" title="为什么要提出 Vega-Lite"></a>为什么要提出 Vega-Lite</h2><p>首先，Vega-Lite 的目标是：</p>
<ul>
<li>通过一种规范来快速的表达你的可视化设计。</li>
<li>提供了简洁的语法和图元便于你快速切换设计。</li>
</ul>
<p>以前的东西做不到吗？其实也不是做不到，只是在有些方面还有很大的提升空间，Vega-Lite 就是在这个方向上很大的一步棋：</p>
<ul>
<li>低等级的可视化语法有更高的自由度，但往往高等级的可视化语言更受偏爱，主要因为其简洁，能快速做出东西，而且能生成低等级的语法供二次开发（Vega-Lite 可以编译成 Vega，而且所有代码都是 JSON 格式）。</li>
<li>低等级的可视化语言没法提供现成的可视化方案（得你自己设计），而高等级的可以直接搜索或推断出适合你的可视化方案，支持在线查看效果（比如用 vega-lite 配套的 Voyager）。</li>
<li>从交互方面来说，现有的高级语法在交互方面比较局限，而低等级语法可能为了定制化还得自己去处理事件回调（例如 D3），这对非专家很不友好且很容易出错。而 Vega-Lite 直接提供更简洁更具表现力的交互（一两行代码就能定义一个交互操作）。</li>
</ul>
<p>为了实现以上的这些愿景，Vega-Lite 主要通过以下方式做出努力：</p>
<ul>
<li><strong>Algebra</strong>  用于将单个 view 合成多 view</li>
<li><strong>Selection</strong> 用于交互选择判定</li>
<li><strong>Transform</strong> 对数据、交互操作转换</li>
<li><strong>Compiler</strong> 编译成 vega 语言，可供二次开发</li>
</ul>
<p>接下来说说它怎么具体实现上面这四个概念的。</p>
<h2 id="Vega-Lite-的具体语法"><a href="#Vega-Lite-的具体语法" class="headerlink" title="Vega-Lite 的具体语法"></a>Vega-Lite 的具体语法</h2><p>可以从两个方面分开介绍，分别是图形方面和交互方面。</p>
<h3 id="Vega-Lite-的具体语法——图形方面"><a href="#Vega-Lite-的具体语法——图形方面" class="headerlink" title="Vega-Lite 的具体语法——图形方面"></a>Vega-Lite 的具体语法——图形方面</h3><h4 id="View-视图"><a href="#View-视图" class="headerlink" title="View 视图"></a>View 视图</h4><p>首先，Vega-Lite 定义一个图形为一个 Unit，所以 Unit 是 Vega-Lite 里图形的最小单位。Unit 的定义是：</p>
<pre><code>unit := (data, transforms, mark-type, encodings)
</code></pre><ul>
<li>data 用来说明数据的来源，支持JSON格式和CSV格式</li>
<li>transform 定义了如何对原始输入数据进行处理</li>
<li>mark 指定了可视化图形</li>
<li>encoding 定义数据到可视化图形的映射规则</li>
</ul>
<p>可视化中视觉通道的设计非常重要，所以其中，encoding 是比较重要的。</p>
<pre><code>encoding := (channel, field, data-type, value, functions, scale, guide)
</code></pre><p>每个 Unit 可以通过一些 operators 变成 View，而 View 又可以通过一些 operators 变成复合的 View。</p>
<p>所以可以这么理解，你每个 operator 的单位是一个视图（可以是 Unit，也可以是 View），而一个 operator 的输出又可以作为下一个 operator 的输入，进而可以形成一个嵌套视图。</p>
<h4 id="Operators-操作"><a href="#Operators-操作" class="headerlink" title="Operators 操作"></a>Operators 操作</h4><p>刚才提到了 operators，你可以把一个 operator 理解成<strong>该以何种方式来整合视图</strong>。Vega-Lite 一共提供了四种 operators，分别是 Layer、Concatenation、Facet、Repeat。</p>
<h5 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h5><p>Layer 很好理解，就是字面意思，将每个 View 重叠；</p>
<pre><code>layer([unit1, unit2, ...], resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/layer.png" alt=""></p>
<h5 id="Concatenation"><a href="#Concatenation" class="headerlink" title="Concatenation"></a>Concatenation</h5><p>Concatenation是将多个单视图水平放置或垂直放置；</p>
<pre><code>hconcat([view1, view2, ...], resolve)
vconcat([view1, view2, ...], resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/concatenation.png" alt=""></p>
<h5 id="Facet"><a href="#Facet" class="headerlink" title="Facet"></a>Facet</h5><p>Facet 是将多个单视图根据数据中的某个 field 进行排布；</p>
<pre><code>facet(channel, data, field, view, scale, axis, resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/facet.png" alt=""></p>
<h5 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h5><p>Repeat 也很好理解，重复放置视图。</p>
<pre><code>repeat(channel, values, scale, axis, view, resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/repeat.png" alt=""></p>
<h3 id="Vega-Lite-的具体语法——交互方面"><a href="#Vega-Lite-的具体语法——交互方面" class="headerlink" title="Vega-Lite 的具体语法——交互方面"></a>Vega-Lite 的具体语法——交互方面</h3><p>任何交互中，<strong>选择</strong>一直是最重要的一个概念，所以 Vega-Lite 的所有交互也都围绕一个概念 —— Selection。首先看 Selection 的定义：</p>
<pre><code>selection := (name, type, predicate, domain|range, event, init, transforms, resolve)
</code></pre><ul>
<li>name: 属性名</li>
<li>type: point, list, intervel</li>
<li>predicate: 决定符合条件的最小集合（判定哪些东西被选进来）</li>
<li>event: 事件如何定义</li>
<li>transform: 操作已选择的元素</li>
</ul>
<p>其中 transform 又最为重要，它定义了已选择之后的操作。这些操作可以进行随机的组合，且用户不需要定义操作之间的先后顺序，因为具体的顺序由编译器定义。</p>
<p>Vega-Lite 目前提供的交互操作一共有 5 种，分别是：project(fields, channels)、toggle(event)、translate(events, by)、zoom(event, factor)、nearest()。</p>
<h5 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h5><p>Project 用来重定义判定函数 predicate。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/project.png" alt=""></p>
<h5 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h5><p>Toggle 表示按下shift键，可以在之前交互结果上，继续进行交互。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/toggle.png" alt=""></p>
<h5 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h5><p>Translate 用于改变交互事件的判断</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/translate.png" alt=""></p>
<h5 id="Zoom-和-Nearest"><a href="#Zoom-和-Nearest" class="headerlink" title="Zoom 和 Nearest"></a>Zoom 和 Nearest</h5><ul>
<li>Zoom操作主要用户视图的缩放</li>
<li>Nearest操作，会将整个视图根据元素的位置分割成Voronoi图，然后将距当前交互的元素最近的元素选择出来</li>
</ul>
<h4 id="其他交互"><a href="#其他交互" class="headerlink" title="其他交互"></a>其他交互</h4><h5 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a>if-then-else</h5><p>简单的条件判断逻辑。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/select.png" alt=""></p>
<h5 id="把选择的数据作为另一个-view-的输入"><a href="#把选择的数据作为另一个-view-的输入" class="headerlink" title="把选择的数据作为另一个 view 的输入"></a>把选择的数据作为另一个 view 的输入</h5><p>上文也说到过，可以理解成视图的嵌套，也可以用作多视图协作。</p>
<h5 id="根据选择的数据设置的比例尺"><a href="#根据选择的数据设置的比例尺" class="headerlink" title="根据选择的数据设置的比例尺"></a>根据选择的数据设置的比例尺</h5><p>结合上一点，就可以把一个视图作为另一个视图的拓展。例如下图的 Overview + Detail 模式。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/detail.png" alt=""></p>
<p><strong>以上三个交互情形都支持与或非逻辑</strong></p>
<h5 id="多视图交互中的歧义"><a href="#多视图交互中的歧义" class="headerlink" title="多视图交互中的歧义"></a>多视图交互中的歧义</h5><p>单视图中的交互，很可能在多视图中引发歧义。例如，在散点图矩阵中，如果在一个矩阵中进行 brush，其他的矩阵怎么配合协作？于是 Vega-Lite 又定义了四种交互协作模式，分别是 single、independent、union、intersect。</p>
<ul>
<li>默认是 single，用户在某个视图中进行交互，其他视图不会做出响应。</li>
<li>其次是 independent，每个视图中的交互互不影响。</li>
<li>union 求并集，是指只要在多视图中任意一个子视图选中的部分，就被算作选中。</li>
<li>intersect 求交集，是指只有在多视图中都选中的部分，才被算作选中。</li>
</ul>
<h3 id="Vega-Lite-编译器"><a href="#Vega-Lite-编译器" class="headerlink" title="Vega-Lite 编译器"></a>Vega-Lite 编译器</h3><p>Vega-Lite 虽然也是用 JSON 写，但它可以编译成更低级的 Vega。其中它的编译器面临两个难点：</p>
<h4 id="两个难点"><a href="#两个难点" class="headerlink" title="两个难点"></a>两个难点</h4><ul>
<li>数据结构不对应</li>
<li>由于vega-lite省略了很多细节设定，所以得编译器自己计算</li>
</ul>
<h4 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h4><p>编译器用四个步骤解决了以上两个难点。</p>
<ul>
<li>语法分析，消除歧义</li>
<li>建立 vega-lite 和 vega 数据结构间的联系</li>
<li>组合、优化数据结构，去除冗余</li>
<li>汇编所有的元素</li>
</ul>
<h2 id="Vega-Lite-局限性"><a href="#Vega-Lite-局限性" class="headerlink" title="Vega-Lite 局限性"></a>Vega-Lite 局限性</h2><p>Vega-Lite 目前虽然已经发布，但依旧在紧锣密鼓的开发，主要是因其现在还没有达到其理想的效果，在以下两方面还有局限性：</p>
<ul>
<li>生成的可视化结果依赖于当前 Vega-Lite 的实现（未来可能会通过解释器层面解决，而不是编译器）</li>
<li>本身固有的模式（通过 predicate function 抽象来解决）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可视化在时下越来越重要，越来越多的行业需要对数据进行展示，而可视化的专家又少之又少，所以很需要一款像 Vega-Lite 一样，简单，智能的系统快速地实现可视化。这可能是可视化工具未来发展的方向 —— 快速实现，快速替换可视化方案，快速展示，接下来再进行二次开发，进而多次迭代。</p>
<p>由此可见 Vega-Lite 前景很大，不过可能还需要再沉淀、开发一段时间，我们拭目以待吧。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Satyanarayan, A., Moritz, D., Wongsuphasawat, K., &amp; Heer, J. (2016). Vega-Lite: A Grammar of Interactive Graphics. IEEE Transactions on Visualization and Computer Graphics, 2626(c), 1–1. <a href="http://doi.org/10.1109/TVCG.2016.2599030" target="_blank" rel="external">http://doi.org/10.1109/TVCG.2016.2599030</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 InfoVis 2016 上，&lt;a href=&quot;http://idl.cs.washington.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UW 交互数据实验室&lt;/a&gt; 提出了一种新的交互数据可视化语法——Veg
    
    </summary>
    
      <category term="Research" scheme="http://geekplux.com/categories/Research/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Research/Visualization/"/>
    
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="Research" scheme="http://geekplux.com/tags/Research/"/>
    
      <category term="交互" scheme="http://geekplux.com/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="Graphics" scheme="http://geekplux.com/tags/Graphics/"/>
    
      <category term="Vega" scheme="http://geekplux.com/tags/Vega/"/>
    
      <category term="Vega-Lite" scheme="http://geekplux.com/tags/Vega-Lite/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建一个私人网盘</title>
    <link href="http://geekplux.com/2016/10/25/how-to-setup-a-personal-cloud.html"/>
    <id>http://geekplux.com/2016/10/25/how-to-setup-a-personal-cloud.html</id>
    <published>2016-10-25T14:13:11.000Z</published>
    <updated>2016-11-02T10:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章主要讲了为什么要搭建私有网盘，以及如何用 docker + ownCloud 搭建。</p>
</blockquote>
<p>前两天，360 云盘宣布将停止个人服务。一石激起千层浪，关于如何选择网盘，如何应对网盘关闭的讨论一下子又变得此起彼伏。没办法，目前的现状是，网盘很难有大的盈利空间，还面对严苛的内容审查和隐私保护，虽然于用户来说提供了便利，但于公司来说实在是一件出力不讨好的事情。</p>
<h2 id="之前的网盘方案"><a href="#之前的网盘方案" class="headerlink" title="之前的网盘方案"></a>之前的网盘方案</h2><p>国外的网盘我一直是三家一起用，分别是 Dropbox 存储代码和一些重要或私密文件；Google Drive 存储一些大文件和私密文件；OneDrive 存储一些电子书（同步太慢了）。国内的网盘我之前只用两家，一是坚果云，放一些个人常用的小文件，包括一些文档和软件配置文件；另一个是百毒云，放一些各处转存来的大文件、自己的照片和学习资料，一方面因其空间大，另一方面因其同步流畅。然而，百毒云前段时间把我的网盘<strong>全面封掉</strong>了，丢失了很多大学时的照片（其它文件要不不重要，要不有备份），申诉无果，实属无奈。</p>
<h2 id="搭建一个只属于自己的网盘"><a href="#搭建一个只属于自己的网盘" class="headerlink" title="搭建一个只属于自己的网盘"></a>搭建一个只属于自己的网盘</h2><p>所以我决定搭建一个只属于自己的网盘。考察了几种方案（包括买 RAID 或 NAS 等），发现已有人在这方面做了努力，提供了像 <a href="https://www.seafile.com/home/" target="_blank" rel="external">Seafile</a> 和 <a href="https://owncloud.org/" target="_blank" rel="external">ownCloud</a> 这样的产品。接下来对比了两个软件，我决定选择用 ownCloud，主要出于以下几点考虑：</p>
<ul>
<li>可以设置是否加密，保证数据安全。</li>
<li>ownCloud 可以用于同步日程、联系人、浏览器书签等，最重要的是<strong>密码管理</strong>，这对于目前有无数密码需要记的我们非常实用。ownCloud 还有个应用商店，大家可以自行发现有用的应用。</li>
<li>ownCloud 提供网页和各种设备、系统的客户端（Windows、Mac、Linux、iOS、Android皆有）进行访问你的网盘。</li>
<li>ownCloud 能将外部存储（如 FTP、WebDAV、Amazon S3，甚至 Dropbox 和 Google Drive）的文件挂载到 ownCloud 上，实现无缝存储和分享。</li>
<li>文件支持版本管理，还有回收站，所以不必担心误删。</li>
</ul>
<h2 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h2><p>首先你得<strong>先有一个自己的 VPS</strong>。。没错，要不然你的数据往哪放，ownCloud 在哪运行。</p>
<p>有了 VPS 之后，就可以按照官网教程一步一步安装搭建了。然而，步骤相当繁琐，你得先安装 PHP、MySQL、 Apache 等等，所以我们要祭出神器 —— docker（这里就不介绍 docker 的用法了，以下内容默认大家对 docker 的基本使用有所了解）。这样一来，之前冗长的步骤，就化成了三步：</p>
<ol>
<li>安装 docker、docker-compose，下载 ownCloud 的 image</li>
<li>配置 docker-compose.yml</li>
<li>配置完毕，启动，打开 ownCloud 主界面配置数据库、管理员等</li>
</ol>
<blockquote>
<p><strong>下面是对上面三步的详细讲解，嫌太长的话可以不看。只需要把下面用到的两个 docker images （owncloud、postgres）下载好，安装 docker-compose 并拷贝 docker-compose.yml 文件到你想要存储 ownCloud 数据的文件夹，然后运行 <code>docker-compose up</code> 就好，一气呵成。</strong></p>
</blockquote>
<h3 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h3><p>安装好 docker 之后，直接下载 <code>owncloud</code> image 运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name owncloud -p 80:80 owncloud</div></pre></td></tr></table></figure>
<p>其实就可以看到 ownCloud 已经运行起来了，访问你的 VPS 地址，就可以看到 ownCloud 的界面。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/docker-owncloud-1.png" alt=""></p>
<p>但这时的 ownCloud 还没有数据库，所以我们还需要用 docker –link 来添加一个数据库存储 ownCloud 的数据，这里用到了 <code>postgres</code> 这个 image（数据库你可以自己定，不一定要用 postgreSQL）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run --name owncloud-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres</div><div class="line">docker run --rm --link owncloud-postgres:owncloud-db --name owncloud -p 80:80 owncloud</div></pre></td></tr></table></figure>
<p>第一条命令会启动一个 postgreSQL 数据库，默认的用户是 postgres，密码设为了 mysecretpassword，host 是 owncloud-db。</p>
<p>但这时我们运行的 docker container 一旦删掉，我们的数据就没有了，所以我们需要用 docker 中的 volumes (或 <a href="https://docs.docker.com/userguide/dockervolumes/#creating-and-mounting-a-data-volume-container" target="_blank" rel="external">docker data volumes</a>)来把 ownCloud 的数据持久化。</p>
<h3 id="配置-docker-compose"><a href="#配置-docker-compose" class="headerlink" title="配置 docker compose"></a>配置 docker compose</h3><p>这样一来，我们得启动两个 container 作为 data-only container，然后再启动 owncloud 和 postgres 关联这两个 data-only container，非常繁杂，幸亏我们有 <code>docker-compose</code> 帮忙。先安装它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install docker-compose</div></pre></td></tr></table></figure>
<p>然后配置 docker-compose.yml，下面配置中的 <code>volumes</code> 就是在配置数据持久化的目录结构。由于我把 docker-compose.yml 存在了VPS 的<code>~/owncloud</code>文件夹下，所以底下 <code>volumes</code> 配置中，冒号前面的宿主目录是那样写的，而冒号后面的是 container 中的目录，具体：</p>
<ul>
<li>/etc/postgresql 存储数据库的配置</li>
<li>/var/lib/postgresql 存储数据库中的数据</li>
<li>/var/www/html/app 存储 ownCloud APP 的数据</li>
<li>/var/www/html/data 存储 ownCloud 的数据</li>
<li>/var/www/html/config 存储 ownCloud 的配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Composition of the containers</span></div><div class="line"></div><div class="line"><span class="attr">postgres-data:</span></div><div class="line"><span class="attr">  image:</span> postgres</div><div class="line"><span class="attr">  command:</span> /bin/<span class="literal">true</span></div><div class="line"><span class="attr">  volumes:</span></div><div class="line"><span class="bullet">    -</span> ~/owncloud/etc/postgresql:/etc/postgresql</div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/lib/postgresql:/var/lib/postgresql</div><div class="line"></div><div class="line"><span class="attr">owncloud-data:</span></div><div class="line"><span class="attr">  image:</span> owncloud</div><div class="line">  <span class="comment"># This is a data container, so we want to exit as soon as the container is created</span></div><div class="line">  <span class="comment"># BUT we will have to fix permissions issues first (33 is the ID of the www-data user)</span></div><div class="line"><span class="attr">  command:</span> /bin/bash -c <span class="string">"/bin/chown -R 33 /var/www/html/data &amp;&amp; /bin/chown -R 33 /var/www/html/config"</span></div><div class="line"><span class="attr">  volumes:</span></div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/www/html/apps:/var/www/html/apps</div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/www/html/data:/var/www/html/data</div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/www/html/config:/var/www/html/config</div><div class="line"></div><div class="line"><span class="attr">owncloud:</span></div><div class="line"><span class="attr">  image:</span> owncloud</div><div class="line"><span class="attr">  ports:</span></div><div class="line"><span class="bullet">    -</span> <span class="number">8080</span>:<span class="number">80</span></div><div class="line"><span class="attr">  volumes_from:</span></div><div class="line"><span class="bullet">    -</span> owncloud-data</div><div class="line"><span class="attr">  links:</span></div><div class="line"><span class="attr">    - postgres:</span>postgres</div><div class="line"><span class="attr">  hostname:</span> cloud</div><div class="line"><span class="attr">  domainname:</span> cloud.example.org <span class="comment"># Change to the hostname you will use</span></div><div class="line"></div><div class="line"><span class="attr">postgres:</span></div><div class="line"><span class="attr">  image:</span> postgres</div><div class="line"><span class="attr">  environment:</span></div><div class="line"><span class="bullet">    -</span> POSTGRES_USER=postgres</div><div class="line"><span class="bullet">    -</span> POSTGRES_PASSWORD=mypostgrespassword</div><div class="line"><span class="attr">  volumes_from:</span></div><div class="line"><span class="bullet">    -</span> postgres-data</div></pre></td></tr></table></figure>
<p>把 docker-compose.yml 配置好之后，只需运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-compose up</div></pre></td></tr></table></figure>
<p>就可以把 ownCloud 运行起来了，上一步中的很多操作，这里一步就搞定了。不过<strong>切记！<code>owncloud-data</code>和<code>postgres-data</code>两个 container 和 volume 千万不要删。删之前请备份</strong>。</p>
<h3 id="ownCloud-配置"><a href="#ownCloud-配置" class="headerlink" title="ownCloud 配置"></a>ownCloud 配置</h3><p>访问你 VPS 的 8080 端口（刚才配置文件里写了）打开 ownCloud 主页，需要做两件事</p>
<ol>
<li>输入管理员的账号和密码</li>
<li>选择数据库用哪个，且输入数据库配置，这里对照我们刚才 docker-compose 里的写的输入就好</li>
</ol>
<p>点击完成，一切 OK，进入文件页面尽情探索吧！</p>
<h2 id="参考-amp-延伸阅读"><a href="#参考-amp-延伸阅读" class="headerlink" title="参考&amp;延伸阅读"></a>参考&amp;延伸阅读</h2><ul>
<li><a href="http://blog.securem.eu/serverside/2015/08/25/setting-up-owncloud-server-in-a-docker-container/" target="_blank" rel="external">Setting up an ownCloud Server in a Docker container using Docker Compose</a></li>
<li><a href="https://github.com/vector090/vector090.github.io/wiki/%E4%BD%BF%E7%94%A8%E5%92%8C%E6%90%AD%E5%BB%BAownCloud%E7%A7%81%E6%9C%89%E4%BA%91%E8%A6%81%E7%82%B9" target="_blank" rel="external">使用和搭建ownCloud私有云要点</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章主要讲了为什么要搭建私有网盘，以及如何用 docker + ownCloud 搭建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前两天，360 云盘宣布将停止个人服务。一石激起千层浪，关于如何选择网盘，如何应对网盘关闭的讨论一下子又变得此起彼伏
    
    </summary>
    
      <category term="Tool" scheme="http://geekplux.com/categories/Tool/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="ownCloud" scheme="http://geekplux.com/tags/ownCloud/"/>
    
      <category term="docker" scheme="http://geekplux.com/tags/docker/"/>
    
      <category term="网盘" scheme="http://geekplux.com/tags/%E7%BD%91%E7%9B%98/"/>
    
      <category term="云" scheme="http://geekplux.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一篇学术论文</title>
    <link href="http://geekplux.com/2016/05/31/how-to-read-a-research-paper.html"/>
    <id>http://geekplux.com/2016/05/31/how-to-read-a-research-paper.html</id>
    <published>2016-05-31T12:49:56.000Z</published>
    <updated>2017-12-01T08:39:57.271Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个<strong>知识过剩</strong>的时代。大量标榜为「干货」的文章每时每刻都在不断地产出，搜索引擎的便捷似乎也让我们离这些「知识」只有一步之遥。然而，随着多年在互联网上的浸淫，我发现<strong>越是容易得到的知识，价值越不大，留存的时间也越不长</strong>。所以，相对于那些东拼西凑组成的所谓干货，一本好书或一篇好的学术论文，才是知识的结晶（单从前后两者成文的时间上就可以很好的证明这点）。</p>
<p>关于「如何阅读一本书」的讨论，已经盈千累万，而关于「如何阅读一篇学术论文」的似乎还凤毛麟角。所以这篇文章我打算写一写我在阅读论文过程中总结出的一些方法，希望能对你有帮助，当然如果你有其他更好的方法，欢迎补充。文章共分为四个部分，第一部分介绍读论文的核心要素，第二部分列出阅读单篇论文的具体步骤，第三部分是一些补充。方法论讲完之后，最后一部分将阐述为什么要阅读文献期刊。</p>
<h2 id="一、阅读论文的核心要素"><a href="#一、阅读论文的核心要素" class="headerlink" title="一、阅读论文的核心要素"></a>一、阅读论文的核心要素</h2><p>根据每个人读论文的目的不同，阅读的侧重点也会有所不同，但都不外乎要获取知识、解决问题，所以无论你的目的是什么，有<strong>三个核心要素</strong>是你在阅读一篇论文时必须掌握的：</p>
<ol>
<li>这篇论文主要表达的是什么？作者的写这篇论文的目的是什么？或者说是这篇文章做出了什么成果？</li>
<li>这篇论文的观点/成果是如何实现的？作者用了哪些论据来支持他的观点/成果？</li>
<li>相关的工作有哪些？在这篇文章之前有什么已成立/取得的观点/成果？作者的观点/成果主要是建立在哪个的基础上？作者的观点/成果比别人突出在哪里？</li>
</ol>
<p>阅读论文不能盲目的去读，要<strong>带着问题去读</strong>才有收获，只要了解了这三个核心要素，就可以对论文有一个整体的印象。</p>
<a id="more"></a>
<h2 id="二、阅读论文的步骤"><a href="#二、阅读论文的步骤" class="headerlink" title="二、阅读论文的步骤"></a>二、阅读论文的步骤</h2><p>针对<strong>单篇</strong>论文：</p>
<ol>
<li><strong>认真</strong>地阅读标题、Abstract 和 Introduction。</li>
<li>把每一个章节的标题、子标题都过一遍，具体的内容先不急着看。</li>
<li>阅读 Conclusion，回应刚才的 Abstract 和 Introduction。</li>
<li>瞥一眼参考文献，看引用了哪些文章，里面有没有自己已经看过的。</li>
</ol>
<p>这四个步骤完毕之后，基本上可以解答上文提到的三个核心问题。而且你还能获得额外的一些信息，比如这篇文章和我研究的相关性、值不值得我精读、写的是否通俗易懂、我的知识储备是否能读等等。</p>
<p>如果得到的判断是这篇文章需要精读，那么我们可以开始下面的步骤：</p>
<ol>
<li>阅读文章的主体，重点注意抛出的观点，和提出的论据。</li>
<li>对于有公式、图表或其他具体论述的地方要多关注，时间足够就认真阅读。</li>
<li>遇到有引用参考文献的地方，先不要打断当前的阅读，但要在脑子里有个印象，以便将来进行相关的阅读，从而更好的理解本文的背景。</li>
</ol>
<p>这三个步骤花的时间可能是上面四个步骤时间的几倍，完成之后基本上对整篇文章的细节都掌握了。如果没有读懂，可能是自己的知识不够，也有可能是状态不好，你可以选择把这篇文章放在一边以后在读，或者再把这三个步骤重复几遍。当然，如果你读懂了，并且这篇文章的内容正是你苦寻已久的及时雨，那么可以进行下面这步：</p>
<ol>
<li>把文章的论证重现一遍。</li>
<li>改动重现过程中的相关步骤，与本文进行对比。</li>
</ol>
<p>完成这步，你对文章的理解程度肯定会比一般人深，如果有新的发现或结论，你还可以与原作者进行交流，或自己在其基础上发表新的论文等。</p>
<h2 id="三、一些补充"><a href="#三、一些补充" class="headerlink" title="三、一些补充"></a>三、一些补充</h2><p>上一节中的阅读步骤都是针对单篇论文的，其实在阅读论文过程中，我们很少是阅读完一篇再读下一篇，而通常是同时读几篇，每篇只读一部分，得到答案就够了。所以针对上述的步骤，还需要一些补充：</p>
<ol>
<li>要获取某个知识/解决方案时，应该是<strong>大规模、分批次</strong>阅读，而<strong>不是逐篇阅读</strong>（通常这篇读不懂的，会在另一篇中有答案）。</li>
<li>拿到一个方向相关的大量论文后，尽可能从标题判断出阅读顺序（也要考虑发表时间）。</li>
<li>阅读单篇论文，<strong>不要逐行阅读</strong>，提炼出适合自己的阅读论文顺序。</li>
<li>阅读论文时<strong>要敢于想象（猜）</strong>，大胆假设，小心验证，很可能一次性就猜对，节约很多时间。</li>
<li>每篇论文中详细的推导过程，很可能你根本不需要懂。</li>
<li>不要有公式恐惧症。关键的公式可能就三五个，其他不懂也没关系。公式之间的恒等式推导过程可以完全略。假如到了万不得已非要看懂的情况，重点看公式推导过程中引入的假设条件，和公式中每个字母所指代的东西。</li>
<li>读不懂的时候，不要气馁，可能是自己的知识储备还不够，也可能是今天的状态不好，先放一边，读下一篇。</li>
</ol>
<p>大量阅读提升广度，精准阅读提升深度。读的越多越熟练。</p>
<h2 id="四、为什么要阅读文献期刊"><a href="#四、为什么要阅读文献期刊" class="headerlink" title="四、为什么要阅读文献期刊"></a>四、为什么要阅读文献期刊</h2><p>只要深入掌握到阅读与分析期刊论文的技巧, 就可以掌握到可能在大学不曾研习过的三种能力:</p>
<ol>
<li>从无组织的知识中检索、筛选、组织知识的能力</li>
<li>对一切既有进行精确批判的独立自主判断能力</li>
<li>创造新知识的能力</li>
</ol>
<p>阅读论文是我在研一后半年才意识到的一件收益很大的事（惭愧），也是一个漫长的旅程。如果你也有幸开始这个旅程，希望你能轻松上路，如果你在途中遇到了困难，希望你能「不求甚解」，从万千论文中挑出自己最容易读懂的读，挑软柿子捏。等走的路多了，自然会知道哪有坑洼，哪有岔路。这些话也送给我自己。</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>姊妹篇：<a href="https://chriszheng.science/2016/06/28/How-to-find-scientific-papers/" target="_blank" rel="external">如何查文献——科研老司机的一点人生经验</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Keshav, S. (2007). How to read a paper. ACM SIGCOMM Computer Communication Review, 1–3. <a href="http://doi.org/10.1145/1273445.1273458" target="_blank" rel="external">http://doi.org/10.1145/1273445.1273458</a></li>
<li>Laramee, R. S. (2011). How to read a visualization research paper: Extracting the essentials. IEEE Computer Graphics and Applications, 31(3), 78–82. <a href="http://doi.org/10.1109/MCG.2011.44" target="_blank" rel="external">http://doi.org/10.1109/MCG.2011.44</a></li>
<li>彭明辉《研究所新生完全求生手册》</li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个&lt;strong&gt;知识过剩&lt;/strong&gt;的时代。大量标榜为「干货」的文章每时每刻都在不断地产出，搜索引擎的便捷似乎也让我们离这些「知识」只有一步之遥。然而，随着多年在互联网上的浸淫，我发现&lt;strong&gt;越是容易得到的知识，价值越不大，留存的时间也越不长&lt;/strong&gt;。所以，相对于那些东拼西凑组成的所谓干货，一本好书或一篇好的学术论文，才是知识的结晶（单从前后两者成文的时间上就可以很好的证明这点）。&lt;/p&gt;
&lt;p&gt;关于「如何阅读一本书」的讨论，已经盈千累万，而关于「如何阅读一篇学术论文」的似乎还凤毛麟角。所以这篇文章我打算写一写我在阅读论文过程中总结出的一些方法，希望能对你有帮助，当然如果你有其他更好的方法，欢迎补充。文章共分为四个部分，第一部分介绍读论文的核心要素，第二部分列出阅读单篇论文的具体步骤，第三部分是一些补充。方法论讲完之后，最后一部分将阐述为什么要阅读文献期刊。&lt;/p&gt;
&lt;h2 id=&quot;一、阅读论文的核心要素&quot;&gt;&lt;a href=&quot;#一、阅读论文的核心要素&quot; class=&quot;headerlink&quot; title=&quot;一、阅读论文的核心要素&quot;&gt;&lt;/a&gt;一、阅读论文的核心要素&lt;/h2&gt;&lt;p&gt;根据每个人读论文的目的不同，阅读的侧重点也会有所不同，但都不外乎要获取知识、解决问题，所以无论你的目的是什么，有&lt;strong&gt;三个核心要素&lt;/strong&gt;是你在阅读一篇论文时必须掌握的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这篇论文主要表达的是什么？作者的写这篇论文的目的是什么？或者说是这篇文章做出了什么成果？&lt;/li&gt;
&lt;li&gt;这篇论文的观点/成果是如何实现的？作者用了哪些论据来支持他的观点/成果？&lt;/li&gt;
&lt;li&gt;相关的工作有哪些？在这篇文章之前有什么已成立/取得的观点/成果？作者的观点/成果主要是建立在哪个的基础上？作者的观点/成果比别人突出在哪里？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;阅读论文不能盲目的去读，要&lt;strong&gt;带着问题去读&lt;/strong&gt;才有收获，只要了解了这三个核心要素，就可以对论文有一个整体的印象。&lt;/p&gt;
    
    </summary>
    
      <category term="Research" scheme="http://geekplux.com/categories/Research/"/>
    
    
      <category term="Research" scheme="http://geekplux.com/tags/Research/"/>
    
      <category term="方法论" scheme="http://geekplux.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="学习" scheme="http://geekplux.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Learning" scheme="http://geekplux.com/tags/Learning/"/>
    
  </entry>
  
  <entry>
    <title>毕业后的两年</title>
    <link href="http://geekplux.com/2016/02/15/two-years-after-graduated.html"/>
    <id>http://geekplux.com/2016/02/15/two-years-after-graduated.html</id>
    <published>2016-02-15T15:03:27.000Z</published>
    <updated>2016-02-15T17:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=16504268&auto=0&height=66"></iframe>

<p>在我们 5 岁的时候，过一年相当于经历人生的 1/5，而到了 25 岁的时候，过一年却相当于只经历了人生的 1/25。时间的重要性似乎随着我们年龄的增长而变得越来越低。主观感受上我们觉得时间走的越来越快了，而实际上却是我们对时空的认知变得扭曲了。</p>
<p>所以我们需要不断整理、回顾自己的人生，就像偶尔给自己留张自拍一样，说不定哪一天就忘记自己当时长什么样了。</p>
<p>距离我上次大学毕业总结（<a href="http://geekplux.com/2014/02/02/goodbye_my_university.html">Goodbye，我的大学</a>）已经过去了两年。都说 20-25 岁的年纪是人生最不怕折腾的年纪，如今我躺在床上，闭眼回想自己这过去的两年，满是<strong>任性</strong>。</p>
<p><em>本文和上次总结不同，将以时（liu）间（shui）线（zhang）的方式来叙述。两年的经历可以分为六个部分，其中五和六两个部分属于持续经历，七是一些胡思乱想。如果你觉得废话太多，可以只看<strong>黑体字</strong>部分或最后的总结。</em></p>
<h2 id="一、初到上海"><a href="#一、初到上海" class="headerlink" title="一、初到上海"></a>一、初到上海</h2><p>这完全是一次没有计划，说走就走的求职之路，当时的我还没意识到「<strong>大学毕业后的第一份工作至关重要</strong>」这一点。</p>
<a id="more"></a>
<h3 id="只呆了一个月的公司"><a href="#只呆了一个月的公司" class="headerlink" title="只呆了一个月的公司"></a>只呆了一个月的公司</h3><p>第一家公司我只呆了一个月。由于是靠朋友关系硬塞进去的，所以我在其中的一个月没有任务，也没有要求，扮演着一个无所事事的角色。天天看 PHP 手册的工作让我很没有成就感，加之公司氛围不怎么好，我很快决定另投简历。</p>
<p><strong>人只有写简历的时候才会觉得自己有多么乏善可陈</strong>。虽然我在大学期间也实习过，但真正想找一份程序员的工作只能靠我仅有的毕设经验（一款 Android APP）。在收到的回应中，其中一个创业团队和我一见钟情。</p>
<p>在这过程中，我要感谢昊哥对我无微不至的照顾，同时也有不少感触：</p>
<ul>
<li><strong>如果对一个环境不满意，而你又改变不了它，直接走</strong>（我真的不是在影射什么）。</li>
<li><strong>简历要在日常积累，而投简历的时候要明确目标</strong>。</li>
<li><strong>自己找到的工作比靠介绍进去的要有成就感的多</strong>。</li>
</ul>
<h3 id="创业艰辛"><a href="#创业艰辛" class="headerlink" title="创业艰辛"></a>创业艰辛</h3><p>辗转来到这家创业公司<a href="http://10years.me" target="_blank" rel="external">十年后</a>。本来我以为我是来作 Android 程序员的，结果第二天 CEO 就和我说：「Android 客户端还有点遥远，不如你来作 Web 前端吧」……从此我走上了这条坑多无比的不归路。</p>
<p>在十年后期间，我最大的感受是创业真的很难。<strong>创业靠的不是独一无二的 Idea，而是团队和决策</strong>。同样的创意，可能展现出来的产品形态完全不同；即使产品思路相同，决策不同也可能导致发展背道而驰；即使决策相同，不同的团队执行起来也是风格迥异。然而，就算思路绝对正确，执行一流，最终也会因为各种各样的问题（有的问题小到不起眼）而中道崩殂。遥想当年 InnoSpace 里那么多的创业团队现在还剩多少。</p>
<p><strong>创业的日子没有那么多快意恩仇，更多的是柴米油盐</strong>。加入一家创业公司，有幸经历这些，让我觉得很幸运。不仅如此，在十年后的日子，也是我走出校门以来最开心的日子。</p>
<h4 id="重要的不是做什么，而是和什么人在一起"><a href="#重要的不是做什么，而是和什么人在一起" class="headerlink" title="重要的不是做什么，而是和什么人在一起"></a>重要的不是做什么，而是和什么人在一起</h4><p>十年后团队里最开始青一色的复旦人，复旦兼容并包却又与众不同的气质在他们身上体现的淋漓尽致。桉哥和冬神可能是我见过最理想化的人了，总给我一种遗世孤立的感觉，和他俩呆在一起的时间最长，受他俩影响最大。此时我才真正理解了为什么毕业后第一份至关重要，因为<strong>我们在象牙塔里对社会没有直观的感受，而抛开乐趣、价值、薪水不谈，第一份工作恰恰帮助初出茅庐的你构建了一个社会认知的雏形，间接的还可能影响你的三观</strong>。以下是我在那段时间感悟到的：</p>
<h4 id="心灵开放"><a href="#心灵开放" class="headerlink" title="心灵开放"></a>心灵开放</h4><p>心态开放我暂且只认识到两点：</p>
<ul>
<li><strong>不设限</strong></li>
<li><strong>不贴标签</strong></li>
</ul>
<p>我们总是在无形之中给自己套上枷锁，事实上<strong>人总比自己想象的更加自由</strong>。生活一成不变的原因大多是因为我们没有打破局限的意识。<strong>不断的尝试新事物，尝试以前不敢做的事才能突破自己</strong>。感谢他们让我认识到这一点，因为他们似乎无所不能。不管我做什么他们都没有黑我嘲笑我，反而是不断的支持与鼓励，这不是表面上的，因为他骨子里都是这种「玩世不恭」的人。</p>
<p>我们也不应给事物设限，<strong>不要因为一点而否定全局</strong>。也<strong>不要给任何人或事物贴标签</strong>，不知道为什么我们在日常生活中特别喜欢贴标签，比如北方人都特别耐寒，南方人都是蛮夷等等。<strong>大多数标签都是针对特定个体在特定环境下的描述，所以抛开影响因子来下定论完全是耍流氓</strong>。事物和人一样，不是一成不变的，也都是多元的，你可以接受他和你共鸣的地方，而忽视其他。</p>
<h4 id="慢即是快"><a href="#慢即是快" class="headerlink" title="慢即是快"></a>慢即是快</h4><p>快节奏社会里很多人都是「急功近利」的，看本书都追求「快速阅读」，我当时也是。但后来我渐渐意识到这有点本末倒置，<strong>持之以恒</strong>才是最重要的。这是我在学习 <a href="http://geekplux.com/2015/01/05/play-ukulele.html">Ukulele</a> 的过程中悟到的。每天弹10分钟，比一天弹几个小时却停练一周要进步快的多。其他事也是这样，<strong>可能你现在看不到任何收益，但只要坚持，总会有量变达到质变的一天</strong>。爱因斯坦都说复利是世界第八大奇迹。</p>
<p>同时，单纯的享受过程也是很有趣的事，就拿读书来说，很多书是不能囫囵吞枣的，你得细嚼慢咽才能吃透它的内容。而且，每天坚持看几页，一年下来也能看不少书。我们不应论量，而应论质。</p>
<h2 id="二、考研岁月"><a href="#二、考研岁月" class="headerlink" title="二、考研岁月"></a>二、考研岁月</h2><p>参加完毕业典礼后，我鬼使神差地萌生了考研的想法，原因有很多，但其实最大的理由只是因为我想体验一下考研是什么样子的。于是，辞职，回家复习。</p>
<p><strong>考研备考可能是我一生中最孤独的日子了</strong>。虽然和高考一样都是朝着一个确切的目标奋斗，但是高考有同学、有老师、有家长，而考研你什么都没有，甚至连复习计划都得自己定，有的只是万一考不上的压力和对考上之后日子的幻想。那时候我坐在自习室里，偶尔会怀疑自己是不是回到了高中，耳畔响起罗大佑的《闪亮的日子》、张雨生的《永远不回头》和赵雷的《我们的时光》等等，然后若有所思的看看窗外。</p>
<p><strong>考研除了孤独，还是脆弱的</strong>。我要感谢毛哥在考研整个复习阶段孜孜不倦鼓励。尤其在最后的阶段，一个小题不会做都可能是悲愤的导火索。每当没有信心的时候，毛哥就会如永动机一样开始鼓励我，这帮我挺过了那最艰苦的岁月。不过不幸的是，<strong>考研有可能和单恋一样，感动的是自己</strong>。</p>
<p>Anyway，<strong>考研的日子是宝贵的，是在这浮躁社会中难有的清静，是聆听内心独白的契机</strong>，坚持下来更是战胜自己的喜悦。最有趣的是，我 Wunderlist 上曾有一个长长的清单，上面写满了那些「等我考完以后」才能做的事，每次看看都会笑。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/2016-02-15%20221528.jpg" alt="自习室"></p>
<h2 id="三、又至上海"><a href="#三、又至上海" class="headerlink" title="三、又至上海"></a>三、又至上海</h2><p>考研的结果是我没有考上华科，无奈之下来沪调剂，结果又因为本科出身太差被各种拒绝，那段时间也是有些心灰意冷，遂决定找工作。其中印象最深的是第一场面试：去饿了么被 <a href="https://github.com/sofish" target="_blank" rel="external">sofish</a> 面试。</p>
<p>半年没写代码的我压根没有准备就去了（我也不知我何来的自信），一答不上来头上就直冒汗。然而 sofish 没有怪我浪费他时间，反而循循善诱，不停的教我如何更加深入的学习前端技术，超级 Nice! 虽然最后被刷，但我仍然很感激这次面试，让我学会了很多。</p>
<p>最终我又选了一家创业公司——一财新媒体。不到半年的时间，从最初的技术团队只有几个人到后来的几十个人，我也算是经历了公司成长最快的一段时期。有趣的是，当时我不仅要写代码，还要负责面试的工作，虽然当时我很不喜欢，但现在看来很有意义的一段经历，至少<strong>让我从面试官的角度体会到了哪些品质、技能是一个合格程序员所必须具备的</strong>。</p>
<p>在一财的日子，可能是<strong>我毕业以来最像「上班」的一段日子</strong>。第一次把自己当作一名职员来看待，第一次体会到上下级，第一次体会到各司其职互相配合的感觉。。。在职场方面我是稚嫩的，幸亏有我可爱的上司经常教我各种人生经验。还有我司各种卖（men）萌（sao）的同事，跟你们互黑真的是非常愉快。</p>
<h2 id="四、杭州的象牙塔"><a href="#四、杭州的象牙塔" class="headerlink" title="四、杭州的象牙塔"></a>四、杭州的象牙塔</h2><p>尽管直到最后辞职，所有人可能都没理解为什么我要去杭师大读研（调剂成功），但我还是毅然决然的去了。</p>
<p>每次做一些重大决定前，<strong>我们其实内心早就有了选择，所谓的分析，调研，到底哪个选项好，其实都是为了印证、迎合自己内心的想法</strong>。每次询问别人的意见，其实只是想让别人认同自己<strong>既定</strong>的想法。</p>
<p>从职场回到校园，很多地方都不适应，尤其是<strong>心态很难转变</strong>。本来是每天都有任务要完成，现在变成了自己给自己找任务；本来每天面对的是实际的业务；现在变成了自己猜测出来的需求，本来每天是按时上班，主动付出，现在变成了每天上课，被动接受。。。我怀疑我到现在都没有彻底转换过来。不过<strong>工作后再读研比大学毕业直接读研有个优势，那就是我知道我要学的是什么</strong>。</p>
<p><strong>读研和本科也有所不同</strong>。研究生更多的是自己找一个问题，运用所学自己去研究，大学则还不理解什么是研究。读论文可能是研究生最常做的事，每每读起一篇优秀的论文，总能深切的体会到什么是「站在巨人的肩膀上」。此外，研究生需要天天呆在实验室，不过好在我大学里就天天泡在实验室，所以对这种实验室-宿舍两点一线的生活没有一丝不适。</p>
<p>然而，由于我总能给自己的偷懒找到恰当的理由，所以<strong>在学校的紧张程度和努力程度远没有工作时的大</strong>。偶尔去西湖浪一浪，美其名曰释放压力。</p>
<h2 id="五、自由职业与外包"><a href="#五、自由职业与外包" class="headerlink" title="五、自由职业与外包"></a>五、自由职业与外包</h2><p>编程也算是一种创造性工作了，自由职业一直是我向往的，外包只是偶尔开开荤。</p>
<p>人生第一个外包来的特别突然，对方提到的技术对于当时的我来说完全不会，但我还是一口答应了下来（毕竟 too young）。Deadline 之前的那一个通宵，可能是我技术提升最快的一夜。虽然这个网页最终还是没令对方满意，但我还是学到了不少前端技术，也深深体会了「不逼自己一把，不知道自己有多优秀」这句话。后来的几个小外包经历，也慢慢让我有了<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODk1MjgwMQ==&amp;mid=400071755&amp;idx=1&amp;sn=f086671ea081b96b7f1268867b38715c#rd" target="_blank" rel="external">盲目的自信</a>。</p>
<p>不过外包归根结底还是有点苦，接过的都冷暖自知。而且<strong>外包过来过去都是没有挑战性的体力活，很难在技术上有所成长</strong>。相对来说，如果有一个稳定的远程工作会好很多，技术会随着业务的增长而增长。</p>
<p>另外我要提一下，从第一份外包到后来的一些机会大多是通过我博客来找到我的，<strong>所以写博客是一件收益巨大的事</strong>，尤其是写<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">优秀的博客</a>。</p>
<h2 id="六、公众号"><a href="#六、公众号" class="headerlink" title="六、公众号"></a>六、公众号</h2><p>运营一个公众号两年半的感想大多都写在了<a href="http://mp.weixin.qq.com/s?__biz=MjM5Mjg0NjMwMQ==&amp;mid=400413023&amp;idx=1&amp;sn=84d3e6670c6aaa4dcaca756b778b25a4#rd" target="_blank" rel="external">晓然，回归</a>里，当时主要说了说心态要平和，但还有一些想在这里絮叨絮叨：</p>
<h3 id="弱关系"><a href="#弱关系" class="headerlink" title="弱关系"></a>弱关系</h3><p>弱关系很重要，因为弱关系可以提供一些「圈外」的信息。而维持弱关系的关键，不在于竭尽所能讨好别人，也不在于想法设法不得罪人，而在于<strong>不断提升自己的价值</strong>。</p>
<h3 id="沉默是金"><a href="#沉默是金" class="headerlink" title="沉默是金"></a>沉默是金</h3><p>三种时候应该沉默：</p>
<ul>
<li>世上 99.9% 事与自己无关，<strong>不要随意发表评论</strong>。</li>
<li><strong>不要好为人师</strong>，总想给别人传授人生经验。</li>
<li>面对诽谤、质疑或者任何让你不爽的言论，<strong>不作回应</strong>是最好的处理方式。</li>
</ul>
<h2 id="七、一些胡思乱想"><a href="#七、一些胡思乱想" class="headerlink" title="七、一些胡思乱想"></a>七、一些胡思乱想</h2><h4 id="不反智"><a href="#不反智" class="headerlink" title="不反智"></a>不反智</h4><p>以我个人的浅见，我觉得反智可能是因为现在社会的价值观单一造成的。以下情况或多或少的出现在身边：</p>
<ul>
<li><strong>结果比过程更重要，文凭比学习的过程更重要</strong></li>
<li><strong>追求知识被认为无用，认真的行为被认为装逼</strong></li>
<li><strong>充满偏见，不想进一步学习，也抑制你学习的冲动</strong></li>
</ul>
<p>我这里不是批判反智的人，<strong>反智的定义很大，而且反智不含褒贬之意</strong>，我只是想要求自己在大多数情况下做到不反智，比如<strong>尊重版权</strong>。我很纳闷为什么有的人会抄的理直气壮，还反过来问我知识是不是应该共享。我觉得知识是应该共享，但更应该尊重创造这些知识的人。</p>
<h3 id="主观"><a href="#主观" class="headerlink" title="主观"></a>主观</h3><p><strong>每个人到底生活于何样的世界，首先取决于这个人对这个世界的理解</strong>。所有的一切，或所谓的现实，都可以分成两个部分：主体和客体。<strong>面对完全一样的客体时，不同的主体意味着所构成的现实完全不同</strong>。</p>
<p>有兴趣可以看看我之前写的一篇关于主观认知的文章——<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODk1MjgwMQ==&amp;mid=400800239&amp;idx=1&amp;sn=938f2a6307aef3b87d01b089496ecc47#rd" target="_blank" rel="external">假如我们的主观意识都是别人操控的</a>。</p>
<p>以上只是我这两年的一些胡思乱想，很多时候我自己也是糊涂的，不过总得有个标准以便偶尔跳脱出来审（si）视（kao）自（ren）己（sheng）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>人是群居动物，环境对人的影响至关重要。不到两年时间，我辗转了几个地方，其中对我影响最大的是在十年后工作的日子，而我最专注、最不浮躁、最无聊的时光是考研的那段，其他的经历好像也都蛮不错，总之是没什么后悔和遗憾。</p>
<p>我做很多事之前都没什么确切的理由，想做便去做了，其实挺任性的。但人生只是个过程，如果日复一日的过着同样的生活真的很无趣。悟已往之不谏，知来者之可追，希望自己在新的一年中能体会更多样的<strong>平凡的人生</strong>吧。最后用一句话来结尾：</p>
<blockquote>
<p>「我还年轻，我渴望上路。带着最初的激情，追寻着最初的梦想，感受着最初的体验，我们上路吧 。」<br>——凯鲁亚克</p>
</blockquote>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=16504268&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;在我们 5 岁的时候，过一年相当于经历人生的 1/5，而到了 25 岁的时候，过一年却相当于只经历了人生的 1/25。时间的重要性似乎随着我们年龄的增长而变得越来越低。主观感受上我们觉得时间走的越来越快了，而实际上却是我们对时空的认知变得扭曲了。&lt;/p&gt;
&lt;p&gt;所以我们需要不断整理、回顾自己的人生，就像偶尔给自己留张自拍一样，说不定哪一天就忘记自己当时长什么样了。&lt;/p&gt;
&lt;p&gt;距离我上次大学毕业总结（&lt;a href=&quot;http://geekplux.com/2014/02/02/goodbye_my_university.html&quot;&gt;Goodbye，我的大学&lt;/a&gt;）已经过去了两年。都说 20-25 岁的年纪是人生最不怕折腾的年纪，如今我躺在床上，闭眼回想自己这过去的两年，满是&lt;strong&gt;任性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文和上次总结不同，将以时（liu）间（shui）线（zhang）的方式来叙述。两年的经历可以分为六个部分，其中五和六两个部分属于持续经历，七是一些胡思乱想。如果你觉得废话太多，可以只看&lt;strong&gt;黑体字&lt;/strong&gt;部分或最后的总结。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、初到上海&quot;&gt;&lt;a href=&quot;#一、初到上海&quot; class=&quot;headerlink&quot; title=&quot;一、初到上海&quot;&gt;&lt;/a&gt;一、初到上海&lt;/h2&gt;&lt;p&gt;这完全是一次没有计划，说走就走的求职之路，当时的我还没意识到「&lt;strong&gt;大学毕业后的第一份工作至关重要&lt;/strong&gt;」这一点。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://geekplux.com/categories/Life/"/>
    
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="生活" scheme="http://geekplux.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Life" scheme="http://geekplux.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>建立索引式的学习方法</title>
    <link href="http://geekplux.com/2015/12/08/learning-by-index.html"/>
    <id>http://geekplux.com/2015/12/08/learning-by-index.html</id>
    <published>2015-12-08T13:53:27.000Z</published>
    <updated>2016-02-03T07:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习方法的重要性不必多言，相信每个人都知道。然而，并不是掌握了好的学习方法，就可以让你事半功倍，而是要找到适合自己的学习方法。<strong>索引式</strong>的学习方法就很适合我。</p>
<h2 id="何为索引式的学习方法"><a href="#何为索引式的学习方法" class="headerlink" title="何为索引式的学习方法"></a>何为索引式的学习方法</h2><p>索引式的学习方法是我自己起的名字，我不知道在别人那里叫什么。其要义是指<strong>在学习一项技能时，先不深究其细节，而是建立索引</strong>。这就像看书时先看目录一样，把目录多看几遍，对整本书的结构有所了解之后，再去看自己想看的章节。</p>
<h2 id="为什么要建立索引式的学习方法"><a href="#为什么要建立索引式的学习方法" class="headerlink" title="为什么要建立索引式的学习方法"></a>为什么要建立索引式的学习方法</h2><h3 id="迅速建立知识框架"><a href="#迅速建立知识框架" class="headerlink" title="迅速建立知识框架"></a>迅速建立知识框架</h3><p>循序渐进，步步为营的学习方法已经不适合现在的节奏了。这我在上次的文章《入门为什么这么难》里已经提到过：<strong>掌握一项技能要迅速掌握其主干，其余的细枝末节都不去管</strong>。</p>
<p>学习一项技能时，你不能保证你目前所在学的东西将来会用到。就算用到，也可能没有你现在所探究的这么深入。那么我们<strong>只需要知道有这个东西，在脑中建立这部分知识的索引，等用到他的时候再去查阅资料重新学习就好</strong>。</p>
<a id="more"></a>
<h3 id="专注突破，实践巩固"><a href="#专注突破，实践巩固" class="headerlink" title="专注突破，实践巩固"></a>专注突破，实践巩固</h3><p>建立索引之后，其他部分的知识可以暂时地抛诸脑后，而把<strong>精力专注在当前的节点</strong>，「集中优势兵力迅速突破」。</p>
<p>表面上，因其不究细节，索引式的学习方法仿佛对知识的了解都浮于表面。但事实上，对于当前在学的、要用的它都力求扎实掌握，熟练运用。</p>
<p>不仅如此，因为索引式的学习方法强调<strong>用时才学</strong>，这就保证你现在要学的，肯定是你即将要用到的。学完之后马上运用，相当于二次学习。<strong>实践会加深对知识的理解</strong>，就像中学时做题是概念的补充一样。</p>
<h2 id="建立索引的核心方法"><a href="#建立索引的核心方法" class="headerlink" title="建立索引的核心方法"></a>建立索引的核心方法</h2><p>如何建立索引？首先要了解怎么样才算真正的把索引建立成功。</p>
<p>建立成功索引的标准是你在<strong>遇到问题时能立马浮现出这是在运用哪一块的知识</strong>。比如需要抠图的时候，应该运用Photoshop的快速选择工具，需要去除水印的时候，应该运用Photoshop的仿制图章工具或者修补工具等等。</p>
<p>所以建立索引的核心方法是<strong>要了解该技能（软件、工具）每一处知识点（功能）的用处是什么</strong>。它能解决什么问题，遇到什么问题的时候需要用到这块的知识。</p>
<p>如果教材里没说，自己也看不懂，就记下这个名词，或者该章节提到的一些关键字。以便<strong>将来搜索时知道用什么关键字去搜，或者搜索结果中提到的关键字能让你联想到是在用哪部分的知识</strong>。</p>
<p>建立索引的方式不拘一格，可以按照知识点去建，也可以按照用途、方向来建，亦或按照学习目的去建，随你喜欢。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>听过那么多的道理，依然过不好一生。见过这么多的学习方法，依旧学不好。索引式的学习方法适合那种学得快忘得也快的人，所以自己多琢磨琢磨，针对自己特点总结出一套方法论才是最好的。尽量提升效益，而不是增加成本。个人愚见，请多指点。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习方法的重要性不必多言，相信每个人都知道。然而，并不是掌握了好的学习方法，就可以让你事半功倍，而是要找到适合自己的学习方法。&lt;strong&gt;索引式&lt;/strong&gt;的学习方法就很适合我。&lt;/p&gt;
&lt;h2 id=&quot;何为索引式的学习方法&quot;&gt;&lt;a href=&quot;#何为索引式的学习方法&quot; class=&quot;headerlink&quot; title=&quot;何为索引式的学习方法&quot;&gt;&lt;/a&gt;何为索引式的学习方法&lt;/h2&gt;&lt;p&gt;索引式的学习方法是我自己起的名字，我不知道在别人那里叫什么。其要义是指&lt;strong&gt;在学习一项技能时，先不深究其细节，而是建立索引&lt;/strong&gt;。这就像看书时先看目录一样，把目录多看几遍，对整本书的结构有所了解之后，再去看自己想看的章节。&lt;/p&gt;
&lt;h2 id=&quot;为什么要建立索引式的学习方法&quot;&gt;&lt;a href=&quot;#为什么要建立索引式的学习方法&quot; class=&quot;headerlink&quot; title=&quot;为什么要建立索引式的学习方法&quot;&gt;&lt;/a&gt;为什么要建立索引式的学习方法&lt;/h2&gt;&lt;h3 id=&quot;迅速建立知识框架&quot;&gt;&lt;a href=&quot;#迅速建立知识框架&quot; class=&quot;headerlink&quot; title=&quot;迅速建立知识框架&quot;&gt;&lt;/a&gt;迅速建立知识框架&lt;/h3&gt;&lt;p&gt;循序渐进，步步为营的学习方法已经不适合现在的节奏了。这我在上次的文章《入门为什么这么难》里已经提到过：&lt;strong&gt;掌握一项技能要迅速掌握其主干，其余的细枝末节都不去管&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;学习一项技能时，你不能保证你目前所在学的东西将来会用到。就算用到，也可能没有你现在所探究的这么深入。那么我们&lt;strong&gt;只需要知道有这个东西，在脑中建立这部分知识的索引，等用到他的时候再去查阅资料重新学习就好&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
    
      <category term="方法论" scheme="http://geekplux.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="学习" scheme="http://geekplux.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Learning" scheme="http://geekplux.com/tags/Learning/"/>
    
  </entry>
  
  <entry>
    <title>为什么我喜欢写代码</title>
    <link href="http://geekplux.com/2015/11/13/why-i-like-coding.html"/>
    <id>http://geekplux.com/2015/11/13/why-i-like-coding.html</id>
    <published>2015-11-13T15:04:22.000Z</published>
    <updated>2016-11-02T10:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我知道很大一部分的程序员，最初都是游戏爱好者。因为喜欢游戏，进而喜欢电脑，研究它，想知道怎么制作个游戏，怎么破解一个游戏等等。这部分因为喜欢一件事进而喜欢上鼓捣代码的人，算作一类。另一类就是我这种，一开始并不知道自己真正喜欢的是什么，甚至不知道什么是代码，但接触了编程之后，就停不下来的人。</p>
<p>虽然我在高考填志愿的时候，专业一栏都写的是「计算机科学与技术」，但我对这个专业的了解比对女性生理结构的了解还少。大一的课程终于接触到了真正的代码，我却没有因此产生浓厚的兴趣。而后来，当运行成功一个自己编写的程序时，那种头皮发麻，一股电流从背脊击穿头部的感觉，让我瞬间明白了这才是我该做一辈子的事。</p>
<h2 id="编程的反馈很快"><a href="#编程的反馈很快" class="headerlink" title="编程的反馈很快"></a>编程的反馈很快</h2><p>编程之所以有趣，最主要的原因是它能即时反馈。你写下一行代码，立即就能知道它的对错；你写完一个程序，一运行就能知道成功与否；如果做的是界面，那就更明显了，代码一变，界面立马就变。</p>
<p>所以编程学起来也特别快，它能给你立马呈现出你这两个小时到底学到了什么。成就感的积攒，又会推动你进行下一步的学习，不停迭代。</p>
<p>人总是喜欢能更快得到回报的东西。</p>
<h2 id="痛并快乐着"><a href="#痛并快乐着" class="headerlink" title="痛并快乐着"></a>痛并快乐着</h2><a id="more"></a>
<p>众所周知，程序员最讨厌八阿哥（Bug)。除非是当天任督二脉被打通，一般情况下程序员写出的代码都会有Bug。有时候找Bug找的真的想撞墙，人都快崩溃了。我至今忘不了当初我上司，每次点击运行之后，大喊一声「决战吧，代码！」的样子。</p>
<p>但只要Bug一被解决，整个人都会「羽化而登仙」。。。被摧残过后的成果最令人兴奋。（不过我在这里友情提醒各位，如果你看到一个程序员眉头紧锁，千万不要去打扰他，不要问我为什么）</p>
<h2 id="编程很实用，且容易出作品"><a href="#编程很实用，且容易出作品" class="headerlink" title="编程很实用，且容易出作品"></a>编程很实用，且容易出作品</h2><p>好的程序员「笔落惊风雨,诗成泣鬼神」，分分钟能做出一个优秀的网站、APP 或实用的小工具。虽然说要做出颠覆世界或者能给自己带来巨额财富的软件很难，但做一个普通的小程序还是没问题的。比如我有个学长，特别喜欢写那种抢秒杀的代码，双十一前后抢到了一部 iPhone 6S 和各种免单。。。</p>
<h2 id="代码改变思维"><a href="#代码改变思维" class="headerlink" title="代码改变思维"></a>代码改变思维</h2><p>Code change the world 这句我一直知道，但代码改变思维我是真切体会到的。尤其是你学的编程语言或者框架多了之后，你的思维会被这些代码所影响。不知不觉，我们的思维方式可能从发散思维，变成了线性思维，或是面对不同的问题采用不同的思维方式。</p>
<p>一切的学科学到最后都是哲学，代码也是有哲学的。它渗透在我们的血液里，给我们渲染出了新的视野。很多程序猿在从业多年之后还保持着强大的好奇心，卓越的学习能力，开阔的眼界，这一定程度上能归功于代码。</p>
<p>虽然现在很多人鼓吹互联网泡沫就要破灭，但我觉得代码仍会是在未来生存必备的技能。美帝宣传「人人都应学编程」不是一句空话。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我知道很大一部分的程序员，最初都是游戏爱好者。因为喜欢游戏，进而喜欢电脑，研究它，想知道怎么制作个游戏，怎么破解一个游戏等等。这部分因为喜欢一件事进而喜欢上鼓捣代码的人，算作一类。另一类就是我这种，一开始并不知道自己真正喜欢的是什么，甚至不知道什么是代码，但接触了编程之后，就停不下来的人。&lt;/p&gt;
&lt;p&gt;虽然我在高考填志愿的时候，专业一栏都写的是「计算机科学与技术」，但我对这个专业的了解比对女性生理结构的了解还少。大一的课程终于接触到了真正的代码，我却没有因此产生浓厚的兴趣。而后来，当运行成功一个自己编写的程序时，那种头皮发麻，一股电流从背脊击穿头部的感觉，让我瞬间明白了这才是我该做一辈子的事。&lt;/p&gt;
&lt;h2 id=&quot;编程的反馈很快&quot;&gt;&lt;a href=&quot;#编程的反馈很快&quot; class=&quot;headerlink&quot; title=&quot;编程的反馈很快&quot;&gt;&lt;/a&gt;编程的反馈很快&lt;/h2&gt;&lt;p&gt;编程之所以有趣，最主要的原因是它能即时反馈。你写下一行代码，立即就能知道它的对错；你写完一个程序，一运行就能知道成功与否；如果做的是界面，那就更明显了，代码一变，界面立马就变。&lt;/p&gt;
&lt;p&gt;所以编程学起来也特别快，它能给你立马呈现出你这两个小时到底学到了什么。成就感的积攒，又会推动你进行下一步的学习，不停迭代。&lt;/p&gt;
&lt;p&gt;人总是喜欢能更快得到回报的东西。&lt;/p&gt;
&lt;h2 id=&quot;痛并快乐着&quot;&gt;&lt;a href=&quot;#痛并快乐着&quot; class=&quot;headerlink&quot; title=&quot;痛并快乐着&quot;&gt;&lt;/a&gt;痛并快乐着&lt;/h2&gt;
    
    </summary>
    
      <category term="Life" scheme="http://geekplux.com/categories/Life/"/>
    
    
      <category term="生活" scheme="http://geekplux.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感想" scheme="http://geekplux.com/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="情感" scheme="http://geekplux.com/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="代码" scheme="http://geekplux.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>
